<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>单表查询（一）</title>
    <link href="/2022/10/20/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/10/20/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>数据查询是数据库操作中使用做多，最重要的内容。为什么这么说呢？因为我们不仅仅要对数据进行存储，我们还要时不时的把不同的信息“翻出来”为我们所用。<code>MySQL</code>为我们提供了功能强大的语句来实现这些操作。</p><p>文章主要介绍如何使用<code>SELECT</code>语句查询数据表中的如何使用<code>SELECT</code>语句查询数据表中的一列或多列数据、使用<code>SELECT</code>语句和关键字进行范围查询。<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/%E6%8F%92%E5%9B%BE.png"></p><h2 id="基本查询语句"><a href="#基本查询语句" class="headerlink" title="基本查询语句"></a>基本查询语句</h2><h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><ul><li>用<code>SELECT</code>语句检索数据表中指定字段的数据；</li><li>用<code>SELECT</code>语句检索数据表中所有字段的数据。</li></ul><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：<br>1.如何获取数据表中指定字段的数据；<br>2.如何获取数据表中的所有数据。</p><h4 id="查询数据表中指定字段的内容"><a href="#查询数据表中指定字段的内容" class="headerlink" title="查询数据表中指定字段的内容"></a>查询数据表中指定字段的内容</h4><p><code>MySQL</code>从数据表中查询数据的基本语句为<code>SELECT</code>语句。</p><p><code>SELECT</code>语句的可选参数比较多，让我们先从最简单的开始，带大家一步一步的深入<code>SELECT</code>语句的使用。</p><p>SELECT 基本语法规则为：<code> SELECT 字段名 FROM 表名;</code> 。<br><strong>举个例子</strong><br>假设我们现在有一张表<code>Mall_products</code>，内容如下：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/1-1.png"></p><p>我们需要从数据表中查询所有商品的名称，你们想想该怎么写？</p><p>查询代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> Mall_products;<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/1-2.png"></p><p>查询过程如下：<img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/1-3.gif"></p><p><strong>分析：</strong><br>在该例子中，我们使用了<code>SELECT</code>语句从<code>Mall_products</code>表中获取名称为<code>prod_name</code>字段下的所有产品名称，字段名称需要紧跟在<code>SELECT</code>关键字之后。</p><p>然而事实上，我们查询数据的时候，往往需要同时查询<code>多个字段</code>下的内容。这时，我们只需要在<code>字段之间</code>加入逗号<code>,</code>即可。</p><p>语法规则为： <code>SELECT 字段名1, 字段名2 FROM 表名;</code> 。<br><strong>举个例子</strong><br>假设我们现在有一张表<code>Mall_products</code>，内容与上例相同。我们需要从数据表中查询所有商品的名称和价格，你们想想该怎么写？</p><p>查询代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> prod_name, prod_price<br><span class="hljs-keyword">FROM</span> Mall_products;<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/1-4.png"></p><p><strong>小提示</strong>： <code>MySQL</code> 中的 <code>SQL</code> 语句对关键字的大小写不敏感， <code>SELECT</code> 和 <code>select</code> 是一样的。 但是许多开发者更喜欢将关键字大写，表名和字段名使用小写，养成这种习惯，以后写出来的脚本就更容易阅读和维护了。</p><h4 id="查询数据表中的所有内容"><a href="#查询数据表中的所有内容" class="headerlink" title="查询数据表中的所有内容"></a>查询数据表中的所有内容</h4><p>如果我们不记得字段名字了，我们还可以查看整张表的内容。这时候，只需要我们用星号<code>*</code>来代替字段的名字，就会得到一整张表的内容。</p><p>语法规则为： <code>SELECT * FROM 表名;</code><br><strong>举个例子</strong><br>假设我们现在有一张表<code>Mall_products</code>。一开始我们并不知道表里都有什么，所以想要查看整张数据表的内容，你们想想该怎么写？</p><p>查询代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> Mall_products;<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/1-5.png"></p><p><strong>小提示</strong>： 虽然使用星号 <code>*</code> 看起来是一件很方便的事情，但是建议大家在不想获取整张表的情况下，还是使用字段名来进行查询。因为很显然，它会降低查询的效率。<br>好了，下面轮到你们来上手试试了！</p><h3 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器<code>Begin-End</code>处补充代码：</p><p>我们为你新建了一个数据表<code>tb_emp</code>，结构如下：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/1-6.png"></p><ul><li>请你查询字段<code>Name</code>和<code>Salary</code>的内容；</li><li>请你查询整张表的内容。</li></ul><p>测试说明<br>我会对你编写的代码进行测试，若与预期输出一致则算通关。</p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## retrieving the Name and Salary ##########<br>select Name ,Salary <span class="hljs-keyword">from</span> tb_emp;<br><br>########## retrieving all the table ##########<br>select * <span class="hljs-keyword">from</span> tb_emp;<br><br>########## End ##########<br></code></pre></td></tr></table></figure><h2 id="带-IN-关键字的查询"><a href="#带-IN-关键字的查询" class="headerlink" title="带 IN 关键字的查询"></a>带 IN 关键字的查询</h2><h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：使用<code>IN</code>关键字检索数据表中指定的数据内容。</p><h3 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：如何使用关键字<code>IN</code>提取数据表中的指定数据内容。</p><h4 id="带IN关键字的查询"><a href="#带IN关键字的查询" class="headerlink" title="带IN关键字的查询"></a>带<code>IN</code>关键字的查询</h4><p><code>IN</code>关键字被用在WHERE语句的后边，用来过滤你所需要查询的内容。更形象的说，<code>IN</code>关键字的使用情形就像点名，点到谁谁就要站出来。<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/2-1.png"></p><p>语法规则为： <code>SELECT 字段名 FROM 表名 WHERE 字段名 IN (n1,n2,n3,...);</code> 。<br>其中，括号内的数字必须为INT格式的数字。被“点到名”的这些括号里数字对应的内容，都要乖乖的站到前边来展示给大家看。</p><p><strong>举个例子</strong><br>假设我们现在有一张表<code>Mall_products</code>，内容如下：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/2-2.png"></p><p>我们会使用<code>IN</code>关键字检索出所有国家代码为<code>1</code>、<code>86</code>和<code>39</code>的商品信息。</p><p>查询代码如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> *<br><span class="hljs-attribute">FROM</span> Mall_products<br><span class="hljs-attribute">WHERE</span> prod_country IN (<span class="hljs-number">1</span>,<span class="hljs-number">87</span>,<span class="hljs-number">39</span>);<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/2-3.png"></p><p>查询过程如下：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/2-4.gif"></p><p>Oopes! 貌似我们刚才输入了三个数字，为什么只查询到了国家代码为<code>1</code>和<code>39</code>的数据内容，<code>87</code>去哪里了？</p><p>因为国家代号<code>87</code>的内容就压根没存在过啊，仔细看看表<code>Mall_products</code>就知道了。</p><h4 id="带NOT-IN关键字的查询"><a href="#带NOT-IN关键字的查询" class="headerlink" title="带NOT IN关键字的查询"></a>带<code>NOT IN</code>关键字的查询</h4><p>聪明的小伙伴一看<code>NOT</code>就知道了，我们是要取反了。刚才我们是在查询括号中出现的内容，加了<code>NOT</code>取反后，就意味着，我们要查询的是除了括号中出现内容外的所有内容。</p><p>语法规则为： <code>SELECT 字段名 FROM 表名 WHERE 字段名 NOT IN (n1,n2,n3,...); </code>。<br><strong>举个例子</strong><br>我们还使用刚才的表<code>Mall_products</code>。现在我们想要查询除了国家代码为<code>86</code>的所有国家的产品内容。</p><p>查询代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> Mall_products<br><span class="hljs-keyword">WHERE</span> prod_country <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">86</span>);<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/2-5.png"></p><p>好了，下面轮到你们来上手试试了！</p><h3 id="编程要求-1"><a href="#编程要求-1" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器<code>Begin-End</code>处补充代码:</p><p>我们为你新建了一个数据表<code>tb_emp</code>，结构如下：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/2-6.png"></p><ul><li>请你查询当<code>Id</code>不等于<code>1</code>时，字段<code>Name</code>和<code>Salary</code>的内容;</li></ul><h3 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h3><p>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/2-7.png"></p><h3 id="我的代码-1"><a href="#我的代码-1" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## retrieving the Name and Salary <span class="hljs-keyword">with</span> IN statement ##########<br>select Name,Salary <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> Id not <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>);<br><br>########## End ##########<br></code></pre></td></tr></table></figure><h2 id="带-BETWEEN-AND-的范围查询"><a href="#带-BETWEEN-AND-的范围查询" class="headerlink" title="带 BETWEEN AND 的范围查询"></a>带 BETWEEN AND 的范围查询</h2><h3 id="任务描述-2"><a href="#任务描述-2" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：使用BETWEEN AND关键字检索数据表中指定的数据内容。</p><h3 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：如何使用关键字<code>BETWEEN AND</code>提取数据表中的指定数据内容。</p><h4 id="带BETWEEN-AND关键字的查询"><a href="#带BETWEEN-AND关键字的查询" class="headerlink" title="带BETWEEN AND关键字的查询"></a>带<code>BETWEEN AND</code>关键字的查询</h4><p>我们已经学会了如何用<code>IN</code>关键字精确查询数据表中的内容，但是在很多时候，我们仅仅是想知道在某一范围内有多少符合条件的数据，这就不得不使用到关键字<code>BETWEEN AND</code>了。</p><p><code>BETWEEN AND</code>需要两个参数支持，一个是范围的开始值，另一个就是结束值了。如果字段值满足指定的范围查询条件，就返回这些满足条件的数据内容。</p><p>语法规则为： <code>SELECT 字段名 FROM 表名 WHERE 字段名 BETWEEN n1 AND n2;</code> 。<br><strong>举个例子</strong><br>假设我们现在有一张表<code>Mall_products</code>，内容如下：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/3-1.png"></p><p>我们将使用<code>BETWEEN AND</code>关键字检索出所有国家代码为<code>1~50</code>的商品的信息。</p><p>查询代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> Mall_products<br><span class="hljs-keyword">WHERE</span> prod_country <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/3-2.png"></p><p>查询过程如下：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/3-3.gif"></p><p>可以看到，返回结果包含了国家代码从<code>1~50之</code>间的字段值。尤其值得注意的是，端点值<code>1</code>也包含在返回结果中。</p><h4 id="带NOT-BETWEEN-AND关键字的查询"><a href="#带NOT-BETWEEN-AND关键字的查询" class="headerlink" title="带NOT BETWEEN AND关键字的查询"></a>带<code>NOT BETWEEN AND</code>关键字的查询</h4><p>像上一关介绍的关键字<code>IN</code>一样，我们还可以对关键字<code>BETWEEN AND</code>进行取反，表示查询指定范围之外的值。</p><p>语法规则为： <code>SELECT 字段名 FROM 表名 WHERE 字段名 NOT BETWEEN n1 AND n2;</code> 。<br><strong>举个例子</strong><br>我们依然使用表Mall_products。现在我们想要查询除了国家代码为1~50的所有国家的产品内容。</p><p>查询代码如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> *<br><span class="hljs-keyword">FROM</span> Mall_products<br><span class="hljs-keyword">WHERE</span> prod_country <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">50</span>;<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/3-4.png"></p><p>由结果可以看出，返回的结果只有大于国家代码<code>50</code>的内容。</p><p>怎么样？简单吧！好了，下面轮到你们来上手试试了！</p><h3 id="编程要求-2"><a href="#编程要求-2" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器<code>Begin-End</code>处补充代码：</p><p>我们为你新建了一个数据表<code>tb_emp</code>，结构如下：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/3-5.png"></p><ul><li>请你查询当字段<code>Salary</code>范围在<code>3000~5000</code>时，字段<code>Name</code>和<code>Salary</code>的内容。</li></ul><h3 id="测试说明-1"><a href="#测试说明-1" class="headerlink" title="测试说明"></a>测试说明</h3><p>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%80%EF%BC%89/3-6.png"></p><h3 id="我的代码-2"><a href="#我的代码-2" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## retrieving the Name and Salary <span class="hljs-keyword">with</span> BETWEEN AND statement ##########<br>select Name,Salary <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> Salary between <span class="hljs-number">3000</span> and <span class="hljs-number">5000</span>;<br><br><br>########## End ##########<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库和表的基本操作（二）</title>
    <link href="/2022/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2022/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><code>MySQL</code>为我们提供了丰富的数据库管理语句，包括向数据表中插入(<code>INSERT</code>)数据内容的语句，修改(<code>UPDATE</code>)数据内容的语句和删除(<code>DELETE</code>)数据内容的语句。</p><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：为表同时插入多条我们规定的记录。</p><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：如何为表一次性插入多条记录。</p><h4 id="为表的所有字段插入数据"><a href="#为表的所有字段插入数据" class="headerlink" title="为表的所有字段插入数据"></a>为表的所有字段插入数据</h4><p>向表中插入数据最简单的方法就是使用<code>INSERT</code>语句。<code>INSERT</code>语句需要你声明要插入内容的表(<code>table</code>)名和内容(<code>values</code>)。</p><p>语法规则：<code>INSERT INTO 表名 (字段名) VALUES (内容);</code><br><strong>举个例子</strong>：<br>假设我们现在有一张空表<code>MyUser</code>如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/1-1.png"></p><p>接下来，我们要往空表中插入一条内容，插入(<code>INSERT</code>)语句为：<br>i<code>nsert into MyUser(name,age) values(&#39;zhnagsan&#39;,18);</code><br>结果为：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/1-2.png"></p><p>插入过程如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/1-3.png"></p><p>我们检索到了一条数据的结果，一条完整的内容已经被填入了空表中。</p><p><strong>分析：</strong><br>在插入数据时，我们指定了所有的字段名，这样的好处是：即使我们打乱了原本字段的排列顺序，只要插入的数据与之匹配，插入都不会出错。其实，还有一种偷懒的办法，就是我们可以不填字段名，但是这样的话，就必须老老实实的按字段顺序来填入相应的数据。</p><h4 id="为表的指定字段插入数据"><a href="#为表的指定字段插入数据" class="headerlink" title="为表的指定字段插入数据"></a>为表的指定字段插入数据</h4><p>有的时候，我们并不想往某个字段内插入完完整整的值，或者说，有的时候我们并没有完整的数据可以整整齐齐插入某个字段。这时候就需要我们只为指定好的字段插入数据了，其他的我们都不用管。换句话说，就是：<br>为表的指定字段插入数据，就是在INSERT中只向部分插入值，而其他字段的值为表定义时的默认值。</p><p><strong>举个例子</strong></p><p>假设我们现在有一张空表 <code>MyUser</code> 如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/1-4.png"></p><p>我们忽略字段 <code>age</code>，为表 <code>MyUser</code> 插入内容:<br><code>insert into MyUser(name) values(&#39;lisi&#39;),(&#39;fawaikuangtu&#39;),(&#39;zhangsan&#39;);</code><br>结果为：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/1-5.png"></p><p>插入过程如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/1-6.png"></p><p>可以看到，由于我们建表时给字段 <code>age</code> 设置的默认值为 <code>Null</code>，所以插入数据时忽略该字段，就会默认给它赋值为空。</p><h3 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器<code>Begin-End</code>处补充代码：</p><ul><li><p>我们为你新建了一个空数据表<code>tb_emp</code>，请你为它同时添加3条数据内容；</p></li><li><p>空数据表结构如下，注意<code>字段3</code> 为<code>DeptId</code>，倒数第二个字母为大写的<code>i</code>：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/1-7.png"></p></li><li><p>需要你同时添加的数据内容为： （注意，是同时插入多条记录）<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/1-8.png"></p></li></ul><h3 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h3><p>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/1-9.png"></p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## bundle insert the value ##########<br>insert into tb_emp value (<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;Nancy&#x27;</span>,<span class="hljs-number">301</span>,<span class="hljs-number">2300.00</span>),(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;Tod&#x27;</span>,<span class="hljs-number">303</span>,<span class="hljs-number">5600.00</span>),(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;Carly&#x27;</span>,<span class="hljs-number">301</span>,<span class="hljs-number">3200.00</span>);<br><br><br>########## End ##########<br>SELECT * FROM tb_emp;<br></code></pre></td></tr></table></figure><h2 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h2><h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h3><p>有道是：人生在世，孰能无过。过而能改，善莫大焉!</p><p>本关就为各位着重介绍数据的更新（<code>UPDATE</code>）。</p><p>本关任务：将数据表中原有的数据修改为本关指定的数据。</p><h3 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：如何使用<code>update</code>来修改已有的数据。</p><h4 id="更新表中指定的内容"><a href="#更新表中指定的内容" class="headerlink" title="更新表中指定的内容"></a>更新表中指定的内容</h4><p>通过上一关的学习，我们已经掌握了<code>INSERT</code>操作！同样，<code>UPDATE</code>操作也很简单，只要记住<code>UPDATE</code>语句三要素就能轻松掌握，它们分别是:</p><ul><li>需要更新的<code>表（table）名</code>；</li><li>需要更新的<code>字段（column）</code>名和它的<code>新内容（value）</code>；</li><li>决定更新哪一条<code>内容（value）</code>的过滤条件。</li></ul><p>语法规则为： <code>UPDATE 表名 SET 字段名1 = 内容1, 字段名2 = 内容2, 字段名3 = 内容3 WHERE 过滤条件;</code> 。<br><strong>举个例子</strong><br>我们现在有一张表<code>Mall_products2</code>，内容如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/2-1.png"></p><p>现在我们想把<code>Span</code>换成<code>Pakistan</code>，当然，地区代码也要换为<code>92</code> 。</p><p>更新(<code>UPDATE</code>)语句为：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams">UPDATE Mall_products2<br><span class="hljs-keyword">SET</span> country_name <span class="hljs-comment">=</span> <span class="hljs-comment">&quot;Pakistan&quot;</span><span class="hljs-comment">, country_id = 92</span><br>WHERE <span class="hljs-comment">id = 2</span>;<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/2-2.png"></p><p>插入过程如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/2-3.gif"></p><p>看上去不难吧，快来练练手吧！</p><h3 id="编程要求-1"><a href="#编程要求-1" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器<code>Begin-End</code>处补充代码：</p><ul><li>我们为你新建了一个数据表<code>tb_emp</code>，并添加了3条数据内容；</li><li>3条数据内容如下表所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/2-4.png"></li></ul><p>请你将<code>Carly</code>改为<code>Tracy</code>，相应的，<code>301</code>改为<code>302</code>，<code>3200.00</code>改为<code>4300.00</code>。<br><strong>注意</strong>：<code>字段3</code>为<code>DeptId</code>，倒数第二个字母为大写的<code>i</code>。</p><h3 id="测试说明-1"><a href="#测试说明-1" class="headerlink" title="测试说明"></a>测试说明</h3><p>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/2-5.png"></p><h3 id="我的代码-1"><a href="#我的代码-1" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight plaintext"><figcaption><span>Company;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs USE"><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## update the value ##########<br>update tb_emp set Name=&#x27;Tracy&#x27;,Salary=4300.00 ,DeptId=302 where id = 3;<br><br><br>########## End ##########<br>SELECT * FROM tb_emp;<br></code></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><h3 id="任务描述-2"><a href="#任务描述-2" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：删除表中的指定行。</p><h3 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：如何删除指定行的数据。</p><h4 id="删除表中的指定行"><a href="#删除表中的指定行" class="headerlink" title="删除表中的指定行"></a>删除表中的指定行</h4><p>从数据表中删除数据内容需要使用<code>DELETE</code>语句，它需要WHERE语句来配合它来指定我们究竟应该删除哪些数据内容。</p><p>语法规则为：<code> DELETE FROM 表名 WHERE 条件语句;</code> 。<br>我们可以指定删除某一行的数据内容，当然，我们还可以指定删除很多行的数据内容，区别就在于条件语句。那么在接下来的例子里，我们来看看很多行内容是怎么删除的。</p><p><strong>举个例子</strong><br>我们现在有一张表<code>Mall_products2</code>，内容如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/3-1.png"></p><p>现在我们想把包含<code>Span</code>和<code>Italy</code>的这两行数据内容同时删除，删除（<code>DELETE</code>）语句为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">DELETE <span class="hljs-keyword">FROM</span> Mall_products2 <br>WHERE <span class="hljs-attribute">id</span>=2 <span class="hljs-keyword">OR</span> <span class="hljs-attribute">id</span>=3;<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/3-2.png"></p><p>删除过程如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/3-3.gif"></p><p>聪明如你，删除多行内容的例子都看懂了，我想删除某一行的数据内容对你们来说简直易如反掌！</p><h4 id="删除表中的所有行"><a href="#删除表中的所有行" class="headerlink" title="删除表中的所有行"></a>删除表中的所有行</h4><p>删除表中的所有行就更简单了。如果需要删除表中所有的行，只需要省略<code>WHERE</code>语句即可。</p><p>语法规则为： <code>DELETE FROM 表名;</code> 。<br><strong>举个例子</strong><br>我们现在有一张表<code>Mall_products2</code>，内容如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/3-4.png"></p><p>现在我们想把表<code>Mall_products2</code>的所有数据内容同时删除，删除（<code>DELETE</code>）语句为：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> Mall_products2;<br></code></pre></td></tr></table></figure><p>结果为：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/3-5.png"></p><p>删除过程如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/3-6.gif"></p><p><strong>小提示</strong>： <code>TRUNCATE TABLE</code> 语句也可以用来删除表中的所有记录。但是与 <code>DELETE</code> 不同的是，<code>TRUNCATE TABLE</code> 语句直接删除的是表，而不是表中的内容，删除结束后还会重新创建一个表。所以它的执行速度会比 <code>DELETE</code> 语句快。 语法为：<code>TRUNCATE TABLE 表名;</code><br>好了，数据的删除就介绍到这里了，是不是跃跃欲试呢？</p><h3 id="编程要求-2"><a href="#编程要求-2" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器<code>Begin-End</code>处补充代码：</p><ul><li>我们为你新建了一个数据表<code>tb_emp</code>，并添加了3条数据内容；</li><li>3条数据内容如下表所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/3-7.png"></li></ul><p>请你将<code>Salary</code>大于<code>3000</code>的数据行删除。</p><h3 id="测试说明-2"><a href="#测试说明-2" class="headerlink" title="测试说明"></a>测试说明</h3><p>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%BA%8C%EF%BC%89/3-8.png"></p><h3 id="我的代码-2"><a href="#我的代码-2" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## delete the value ##########<br>delete <span class="hljs-keyword">from</span> tb_emp <span class="hljs-keyword">where</span> Salary&gt;<span class="hljs-number">3000</span>;<br><br><br>########## End ##########<br><br>SELECT * FROM tb_emp;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库和表的基本操作（一）</title>
    <link href="/2022/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2022/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>主要内容：查看表结构与修改表名、修改字段名与字段数据类型、添加与删除字段、修改字段的排列位置、删除表的外键约束<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/%E6%8F%92%E5%9B%BE.png"></p><h2 id="查看表结构与修改表名"><a href="#查看表结构与修改表名" class="headerlink" title="查看表结构与修改表名"></a>查看表结构与修改表名</h2><h3 id="任务描述"><a href="#任务描述" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：修改表名，并能顺利查询到修改后表的结构。</p><h4 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h4><p>为了完成本关任务，你需要掌握：<br>1.如何查看表的结构；<br>2.如何修改表的名称。</p><h4 id="查看数据表基本结构"><a href="#查看数据表基本结构" class="headerlink" title="查看数据表基本结构"></a>查看数据表基本结构</h4><p>有强迫症或健忘症的小伙伴们在建好数据库和表以后，通常会怀疑自己刚才是不是敲错了，怎么办？如果不是使用图形界面是不是就没法查看啦？</p><p>不存在的，这就告诉你查看口令：<code>DESCRIBE</code><br>语法规则为:<code>DESCRIBE 表名；</code></p><p>大小写不敏感哟！<br><code>DESCRIBE</code>可以查看表的字段信息，包括：字段名、字段数据类型、是否为主键、是否有默认值等。</p><p>比如本岛主新建了一个名叫<code>Products</code>的表，结构如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/Products.png"></p><p>现在来看看“现场”，用<code>DESCRIBE</code>查表的结构是这样的。<br>其中，该结构中各个字段的含义分别为：</p><p><code>NULL</code>：表示该列是否能存储 NULL 值；</p><p><code>Key</code>：表示该列是否已编制索引；</p><p><code>PRI</code>：表示该列是此表主键的一部分；</p><p><code>UNI</code>：表示该列是 UNIQUE 索引的一部分；</p><p><code>MUL</code>：表示在列中某个给定值允许出现多次；</p><p><code>Default</code>：表示该列是否有默认值，如果有的话值是多少；</p><p><code>Extra</code>：表示可以获取的与给定列有关的附加信息。<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE1.gif"></p><h4 id="查看数据表详细结构"><a href="#查看数据表详细结构" class="headerlink" title="查看数据表详细结构"></a>查看数据表详细结构</h4><p>什么？你发现表建错了，你想知道错在哪里了？<br>那就用<code>SHOW CREATE TABLE</code>语句吧。</p><p>语法规则为：<code>SHOW CREATE TABLE 表名;</code> 。<br>还是刚才那个例子，让我们看看<code>SHOW CREATE TABLE</code>有什么能耐。<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE2.gif"><br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE3.png"><br>可以看到，使用 <code>SHOW CREATE TABLE</code> 语句，不仅仅可以返回给我们建表时所写的详细语句，而且还可以查看存储引擎和字符编码。<br>再告诉大家一个小诀窍，是不是觉得返回的结果排版有点乱。我们加上<code>\G</code>后效果就会有所改善哟，来看看！<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE4.gif"></p><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><p>随着表越来越多，有时候你会后悔之前的数据表的名字根本没有认真斟酌过，想要重新命名一下，可以做到吗？</p><p>答案是：可以！<code>MySQL</code>是通过<code>ALTER TABLE</code>语句来修改表名的。</p><p>语法规则为：<code>ALTER TABLE 旧表名 RENAME 新表名;</code> 。<br>举个例子，我们先用<code>SHOW TABLES</code>看看我们的数据库中有什么表吧。<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE5.png"><br>可以看到，我们目前已经有了两张表，分别叫<code>Products</code>和<code>tb_emp</code>。</p><p>接下来，我们使用<code>ALTER TABLE</code>为<code>Products</code>改名。<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE6.gif"></p><p>改名成功！<code>Products</code>成功变成了<code>Mall_products</code>。<br>接下来你们可以自行体验一下了！</p><h3 id="编程要求"><a href="#编程要求" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器补充代码：</p><ul><li><p>把数据表<code>tb_emp</code>改名为<code>jd_emp</code>；</p></li><li><p>查看该数据库下数据表的列表；</p></li><li><p>查看数据表<code>jd_emp</code>的基本结构。</p></li></ul><p><strong>测试说明</strong><br>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/%E5%9B%BE7.png"></p><h3 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## modify the table name ##########<br>alter table tb_emp rename jd_emp;<br><br><br>########## show tables <span class="hljs-keyword">in</span> this database ##########<br>show tables;<br><br><br>########## describe the table ##########<br>describe jd_emp;<br><br><br>########## End ##########<br></code></pre></td></tr></table></figure><h2 id="修改字段名与字段数据类型"><a href="#修改字段名与字段数据类型" class="headerlink" title="修改字段名与字段数据类型"></a>修改字段名与字段数据类型</h2><h3 id="任务描述-1"><a href="#任务描述-1" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：修改表中的字段名，并修改字段的数据类型。</p><h3 id="相关知识-1"><a href="#相关知识-1" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：1.如何修改字段名；2.如何修改字段的数据类型。</p><h4 id="修改字段名"><a href="#修改字段名" class="headerlink" title="修改字段名"></a>修改字段名</h4><p>有时，在我们建好一张表后会突然发现，哎呀！字段名貌似写错了！怎么办？要删了表再重新建一个新表吗？还是要删了这个字段再新建一个新的字段？<br>都不用，<code>MySQL</code> 中修改字段名称也有专门的语句，接近于自然语言，很好记忆。</p><p>语法规则为： <code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 新数据类型;</code> 。<br>举个例子：<br>现在我们要把表<code>Mall_products</code>中的字段<code>prod_id</code>改名为<code>ID</code>。表结构如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/2-1.png"></p><p>输入命令：<code>ALTER TABLE Mall_products CHANGE prod_id ID varchar(20);</code>。执行过程如下所示。简单吧！<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/2-2.gif"></p><p><strong>小提示</strong>： 如果不需要修改字段的数据类型，可以把新字段的数据类型设置为和原来一样，但是！千万不要空着它！</p><h4 id="修改字段数据类型"><a href="#修改字段数据类型" class="headerlink" title="修改字段数据类型"></a>修改字段数据类型</h4><p>随着存储的数据越来越多，数据库新人可能会发现，哎呀，当初预留的数据类型已经不能满足要求了，或者当初预留的字符太少了，怎么办？怎么修改？规则来了。</p><p>语法规则为： <code>ALTER TABLE 表名 MODIFY 字段名 数据类型;</code> 。<br>举个例子：<br>现在我们要把表<code>Mall_products</code>中的字段<code>ID</code>的数据类型改为<code>varchar(30)</code>。表结构如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/2-3.png"></p><p>输入命令：<code>ALTER TABLE Mall_products MODIFY ID varchar(30);</code>。执行过程如下所示。<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/2-4.gif"></p><p><code>ID</code>的数据类型<code>varchar(20)</code>成功变成了<code>varchar(30)</code>。<br>接下来你们可以自行体验一下了！</p><h3 id="编程要求-1"><a href="#编程要求-1" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器补充代码:</p><ul><li>把数据表<code>tb_emp</code>的字段Id改名为<code>prod_id</code>，数据类型不变；</li><li>把数据表<code>tb_emp</code>字段<code>Name</code>的数据类型改为<code>varchar(30)</code>。</li></ul><p>数据表结构如下:<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/2-5.png"></p><h3 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h3><p>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/2-6.png"></p><h3 id="我的代码-1"><a href="#我的代码-1" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## change the column name ##########<br>alter table tb_emp change Id prod_id int(<span class="hljs-number">11</span>);<br><br><br>########## change the data type <span class="hljs-keyword">of</span> column ##########<br>alter table tb_emp modify Name varchar(<span class="hljs-number">30</span>);<br><br><br>########## End ##########<br><br>DESCRIBE tb_emp;<br></code></pre></td></tr></table></figure><h2 id="添加与删除字段"><a href="#添加与删除字段" class="headerlink" title="添加与删除字段"></a>添加与删除字段</h2><h3 id="任务描述-2"><a href="#任务描述-2" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：分别在表的<strong>最后一列</strong>、<strong>第一列</strong>和<strong>指定列后</strong>添加新的字段，并删除表中的指定字段。</p><h3 id="相关知识-2"><a href="#相关知识-2" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：<br>1.如何在指定位置添加新的字段，<br>2.如何删除指定的字段。</p><h4 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h4><p>因为甲方的业务需求是不停变化的，所以在数据库操作中，添加字段可是常有的事。一个完整的字段包括：<code>字段名</code>、<code>数据类型</code>和<code>完整性约束</code>。</p><p>语法规则为： <code>ALTER TABLE 表名 ADD 新字段名 数据类型 [约束条件] [FIRST|AFTER] 已存在字段名;</code> 。<br>以下是在 <code>MySQL</code> 中常用的约束。</p><p><code>NOT NULL</code> 约束：确保某列不能有 NULL 值。</p><p><code>DEFAULT</code> 约束：当某列没有指定值时，为该列提供默认值。</p><p><code>UNIQUE</code> 约束：确保某列中的所有值是不同的。</p><p><code>PRIMARY Key</code> 约束：唯一标识数据库表中的各行&#x2F;记录。</p><p><code>CHECK</code> 约束：<code>CHECK</code> 约束确保某列中的所有值满足一定条件。</p><p><strong>在表的最后一列添加字段</strong><br>只要不做<code>[FIRST|AFTER]</code>的位置说明，在添加字段时<code>MySQL</code>会默认把新字段加入到表的最后一列。</p><p>举个例子：<br>现在我们要把字段<code>prod_country</code>添加到表<code>Mall_products</code>的最后一列。表结构如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/3-1.png"></p><p>输入命令：<br><code>ALTER TABLE Mall_products ADD prod_country varchar(30)</code>;<br>执行结果如下所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/3-2.png"></p><p><strong>在表的第一列添加字段</strong><br>如果我们想在第一列添加新的字段，只需做FIRST的位置说明。</p><p>举个例子：<br>现在我们要把字段<code>prod_country</code>添加到表<code>Mall_products</code>的第一列。</p><p>输入命令：<br><code>ALTER TABLE Mall_products ADD prod_country varchar(30) FIRST;</code><br>执行结果如下所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/3-3.png"></p><p><strong>在表的指定列后添加字段</strong><br>如果我们想在某一列后面添加新的字段，只需做<code>AFTER</code>的位置说明，然后注明你想让它添加在哪个字段的后面即可。</p><p>举个例子：<br>现在我们要把字段<code>prod_country</code>添加到表<code>Mall_products</code>的 <code>prod_name</code>字段的后面。</p><p>输入命令：<br><code>ALTER TABLE Mall_products ADD prod_country varchar(30) AFTER prod_name;</code><br>执行结果如下所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/3-4.png"></p><p>总之，想要添加新的字段，记住绿色框里的语法规则就能记住三种位置的添加方式。</p><h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><p>有添加的需求就会有删除的需求。删除一个字段就是将数据表中的某个字段从表中移除。</p><p>语法规则为： <code>ALTER TABLE 表名 DROP 字段名;</code> 。<br>举个例子：<br>现在我们要把字段<code>prod_price</code>从表<code>Mall_products</code>中删除。表结构如上图结果所示。</p><p>输入命令：<br><code>ALTER TABLE Mall_products DROP prod_price;</code><br>执行结果如下所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/3-5.png"></p><p>字段<code>prod_price</code>成功删除！<br>接下来你们可以自行体验一下了！</p><h3 id="编程要求-2"><a href="#编程要求-2" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器补充代码:</p><ul><li>在数据表<code>tb_emp</code>的<code>Name</code>字段后添加字段<code>Country</code>，数据格式为<code>varchar(20)</code>；</li><li>删除数据表<code>tb_emp</code>中的字段<code>Salary</code>。</li></ul><p>数据表结构如下:<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/3-6.png"></p><h3 id="测试说明-1"><a href="#测试说明-1" class="headerlink" title="测试说明"></a>测试说明</h3><p>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/3-7.png"></p><h3 id="我的代码-2"><a href="#我的代码-2" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## add the column ##########<br>alter table tb_emp add Country varchar(<span class="hljs-number">20</span>) after Name;<br><br> <br>########## delete the column ##########<br>alter table tb_emp drop Salary;<br><br><br>########## End ##########<br><br>DESCRIBE tb_emp;<br></code></pre></td></tr></table></figure><h2 id="修改字段的排列位置"><a href="#修改字段的排列位置" class="headerlink" title="修改字段的排列位置"></a>修改字段的排列位置</h2><h3 id="任务描述-3"><a href="#任务描述-3" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：修改表中某字段的顺序，分别将其排至表中的第一列与指定列之后。</p><h3 id="相关知识-3"><a href="#相关知识-3" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：如何将某字段排至表中的指定位置。</p><h4 id="修改字段的排列位置-1"><a href="#修改字段的排列位置-1" class="headerlink" title="修改字段的排列位置"></a>修改字段的排列位置</h4><p>在一个数据表被创建的时候，其字段的排列顺序就已被确定了。不能变了吗？怎么可能，一锤子买卖没人敢做。</p><p>我们可以通过<code>ALTER TABLE</code>来改变表中字段的相对位置。</p><p>语法规则为： <code>ALTER TABLE 表名 MODIFY 字段1 数据类型 FIRST|AFTER 字段2;</code> 。<br>其中，<code>字段1</code>指要修改位置的字段，<code>FIRST</code>与<code>AFTER </code>字段2为可选参数。</p><h4 id="修改字段为表的第一个字段"><a href="#修改字段为表的第一个字段" class="headerlink" title="修改字段为表的第一个字段"></a>修改字段为表的第一个字段</h4><p>如果我们想把字段的位置调整到第一列，只需做<code>FIRST</code>的位置说明。</p><p><strong>举个例子</strong><br>现在我们要把字段<code>prod_price</code>调整到表<code>Mall_products</code>的第一列。<code>Mall_products</code>表结构如下所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/4-1.png"></p><p>输入命令：<br><code>ALTER TABLE Mall_products MODIFY prod_price FLOAT FIRST;</code></p><p>执行过程如下所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/4-2.gif"></p><h4 id="修改字段到表的指定列之后"><a href="#修改字段到表的指定列之后" class="headerlink" title="修改字段到表的指定列之后"></a>修改字段到表的指定列之后</h4><p>还有一种位置调整的方法可以让你把想调整的字段放在除了第一列的任何位置。调整的时候需要做<code>AFTER 字段2</code>的&#96;位置说明。</p><p><strong>举个例子</strong><br>现在我们要把字段<code>prod_price</code>调整到字段<code>prod_country</code>的后面。<code>Mall_products</code>表结构如下所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/4-3.png"></p><p>输入命令：<br><code>ALTER TABLE Mall_products MODIFY prod_price FLOAT AFTER prod_country;</code></p><p>执行过程如下所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/4-4.gif"></p><p>调整成功！<br>接下来你们可以自行体验一下了！</p><h3 id="编程要求-3"><a href="#编程要求-3" class="headerlink" title="编程要求"></a>编程要求</h3><p>根据提示，在右侧编辑器补充代码:</p><p>将数据表<code>tb_emp</code>的<code>Name</code>字段移至第一列，数据格式不变；</p><p>将<code>DeptId</code>字段移至<code>Salary</code>字段的后边，数据格式不变。</p><p>数据表结构如下:<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/4-5.png"></p><h3 id="测试说明-2"><a href="#测试说明-2" class="headerlink" title="测试说明"></a>测试说明</h3><p>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/4-6.png"></p><h3 id="我的代码-3"><a href="#我的代码-3" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## modify the column to top ##########<br>alter table tb_emp modify Name varchar(<span class="hljs-number">25</span>) first;<br><br><br>########## modify the column to the rear <span class="hljs-keyword">of</span> another column ##########<br>alter table tb_emp modify DeptId int(<span class="hljs-number">11</span>) after Salary;<br><br><br>########## End ##########<br><br>DESCRIBE tb_emp;<br></code></pre></td></tr></table></figure><h2 id="删除表的外键约束"><a href="#删除表的外键约束" class="headerlink" title="删除表的外键约束"></a>删除表的外键约束</h2><h3 id="任务描述-4"><a href="#任务描述-4" class="headerlink" title="任务描述"></a>任务描述</h3><p>本关任务：删除表中的外键约束。</p><h3 id="相关知识-4"><a href="#相关知识-4" class="headerlink" title="相关知识"></a>相关知识</h3><p>为了完成本关任务，你需要掌握：如何删除表的外键约束</p><h4 id="删除表的外键约束-1"><a href="#删除表的外键约束-1" class="headerlink" title="删除表的外键约束"></a>删除表的外键约束</h4><p>我们曾在第一章中讲过外键的作用，以及如何创建一个表的外键。建立了外键我们就建立起了两张表的关联关系，那如果我想删除主表呢？为了确保数据库的正确性，我们必须先解除两个表之间的关联关系，那就是删除外键约束啦！让我们先来看看删除外键约束的语法规则。</p><p>语法规则为： <code>ALTER TABLE 表名 DROP FOREIGN KEY 外键约束名;</code> 。<br><strong>举个例子</strong>：<br>我们先建立了一个主表<code>country</code>，表结构如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/5-1.png"></p><p>然后建立一个有外键约束的子表<code>Mall_products2</code>，让它的键<code>country_id</code>作为外键关联到<code>country</code>的主键<code>id</code>。<code>SQL</code>语句如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Mall_products2<br>(<br>id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">PRIMARY KEY</span>,<br>country_name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>country_id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">CONSTRAINT</span> prod_country <span class="hljs-keyword">FOREIGN KEY</span>(country_id) <span class="hljs-keyword">REFERENCES</span> country(id)<br>)<br></code></pre></td></tr></table></figure><p>上述语句成功执行后，在表<code>Mall_products2</code>上添加了名称为<code>prod_country</code>的外键约束，外键名称为<code>prod_country</code>，依赖于表<code>country</code>的主键<code>id</code>，从下图中可以看到，已经成功添加了表的外键：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/5-2.png"></p><p>M<code>all_products2</code>表结构如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/5-3.png"></p><p>下面开始删除外键约束，语句如下：<br><code>ALTER TABLE Mall_products2 DROP FOREIGN KEY prod_country;</code></p><p>使用<code>SHOW CREATE TABLE</code>查看表 <code>M</code>all_products2&#96; 的结构，结果如下：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/5-4.png"></p><p>我们可以看到，<code>FOREIGN KEY</code>不见了，外键约束删除成功！<br>接下来你们可以自行体验一下了！</p><h3 id="编程要求-4"><a href="#编程要求-4" class="headerlink" title="编程要求"></a>编程要求</h3><p>我们已经为你建立了主表<code>tb_dept</code>和子表<code>tb_emp</code>，在表<code>tb_emp</code>上添加了名称为<code>emp_dept</code>的外键约束，外键名称为<code>DeptId</code>，依赖于表<code>tb_dept</code>的主键<code>Id</code>，下面那是两张表的结构展示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/5-5.png"><br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/5-6.png"></p><p>请你根据提示，在右侧编辑器<code>Begin-End</code>中补充代码:</p><ul><li>删除数据表<code>tb_emp</code>的外键约束<code>emp_dept</code>。</li></ul><h3 id="测试说明-3"><a href="#测试说明-3" class="headerlink" title="测试说明"></a>测试说明</h3><p>我会对你编写的代码进行测试，最终结果会如下图所示：<br><img src="/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%EF%BC%88%E4%B8%80%EF%BC%89/5-7.png"></p><h3 id="我的代码-4"><a href="#我的代码-4" class="headerlink" title="我的代码"></a>我的代码</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">USE Company;<br><br>#请在此处添加实现代码<br>########## Begin ##########<br><br>########## delete the <span class="hljs-keyword">foreign</span> key ##########<br>alter table tb_emp drop <span class="hljs-keyword">foreign</span> key emp_dept;<br><br>########## End ##########<br>SHOW CREATE TABLE tb_emp \G;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成抽点名单</title>
    <link href="/2022/10/16/%E7%94%9F%E6%88%90%E6%8A%BD%E7%82%B9%E5%90%8D%E5%8D%95/"/>
    <url>/2022/10/16/%E7%94%9F%E6%88%90%E6%8A%BD%E7%82%B9%E5%90%8D%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><p><strong>背景</strong><br>栋哥对大家第一次结对编程作业的原型设计感到很满意，为了尽快让同学们使用上软件，于是栋哥花一晚上时间开发了一个点名小程序。但是在上线运行过后，发现了一些问题：</p><p>大多数老师习惯在每次上课后或下课前的一小段时间内进行点名。<br>如果采用全点的方式，在这段时间里，后端服务器需要处理大量的请求，拥塞导致响应速度变慢，给点名小程序带来极差的使用体验。<br>采用随机抽点的方式，能够有效减少并发量，但是无法保证点名的质量，难以有效抓出没有到教室的同学。<br>所以栋哥急需大家设计一个算法来解决这个问题，要求能够最小化向后端发送的请求次数，最大化抓出缺勤同学的数量。</p><p><strong>具体要求</strong><br>定义5门课程，每个课程班级人数为90人，一学期共20次课。每门课程均有5-8位同学缺席了该学期80%的课，此外每次课程均还有0-3位同学由于各种原因缺席。</p><p><strong>参数定义：</strong><br>请求次数：定义在一次点名中，获取一位同学是否到达课堂的情况为一次请求。<br>有效点名：一位同学缺席该课程的一次课，算法在这次课上抽点到该同学，视为一次有效点名，一次课可包含多次有效点名。</p><p><strong>评价标准：</strong><br><img src="/img/%E7%94%9F%E6%88%90%E6%8A%BD%E7%82%B9%E5%90%8D%E5%8D%95/%E8%AF%84%E4%BB%B7%E6%A0%87%E5%87%86.png"></p><p><strong>输入</strong><br>五门课程的全部人员到勤信息</p><p><strong>输出</strong><br>E、五门课程的抽点方案</p><p><strong>要求</strong><br>最大化E，该标准将作为确定本次作业作业得分的主要依据之一<br>输入的数据，另外编写生成程序随机实现。<br>为输入输出设计标准化、通用化、可扩展的接口，能为该智能匹配程序模块后期可能的整合入系统提供便利。<br>输入输出的格式，如采用文本文件或数据库的方式输入，可自由讨论确定。<br>可为智能抽点算法额外的添加一些合理的辅助搜索信息，如绩点等，可自由讨论确定。<br>代码具有规范性。<br>实现的程序语言不做限制性要求。</p><h3 id="一、输入输出处理问题"><a href="#一、输入输出处理问题" class="headerlink" title="一、输入输出处理问题"></a>一、输入输出处理问题</h3><p>我们计划使用excel表格作为输入形式，需要自学如何实现文件读写。</p><h3 id="二、算法设计"><a href="#二、算法设计" class="headerlink" title="二、算法设计"></a>二、算法设计</h3><p>在考虑如何最大化E值上并尽量覆盖全体学生，我们经讨论后，思路为：<br>a.依据学生个人E值和个人总请求次数作为划分标准，将学生分为两类；<br>b.按不同比例从两类学生中抽点学生。</p><h3 id="三、使用过程"><a href="#三、使用过程" class="headerlink" title="三、使用过程"></a>三、使用过程</h3><h4 id="（一）环境搭建"><a href="#（一）环境搭建" class="headerlink" title="（一）环境搭建"></a>（一）环境搭建</h4><p>请自行搭建java环境</p><h4 id="（二）数据生成"><a href="#（二）数据生成" class="headerlink" title="（二）数据生成"></a>（二）数据生成</h4><p>将项目克隆到本地，找到CreateData.jar 文件（一般情况下在此路径：second_teamwork–&gt;RandInfo–&gt; CreateDate.jar）。<br><img src="/img/%E7%94%9F%E6%88%90%E6%8A%BD%E7%82%B9%E5%90%8D%E5%8D%95/%E6%88%AA%E5%B1%8F1.png"><br>双击运行或在此目录下打开命令窗口输入 <code>java -jar CreateData.jar </code>。运行之后在D盘生成了5个班级信息表，如果运行后没有效果或者报错，请将此目录下的5个班级信息表（class1.xls ~ class5.xls）复制到D盘中。<br><img src="/img/%E7%94%9F%E6%88%90%E6%8A%BD%E7%82%B9%E5%90%8D%E5%8D%95/%E6%88%AA%E5%B1%8F2.png"><br><img src="/img/%E7%94%9F%E6%88%90%E6%8A%BD%E7%82%B9%E5%90%8D%E5%8D%95/%E6%88%AA%E5%B1%8F4.png"></p><h4 id="（三）抽点方案"><a href="#（三）抽点方案" class="headerlink" title="（三）抽点方案"></a>（三）抽点方案</h4><p>运行CreateData.jar文件后，在项目中找到CreateList.jar文件（一般情况下在此路径：second_teamwork–&gt;CreateList–&gt; CreateList.jar）。<br><img src="/img/%E7%94%9F%E6%88%90%E6%8A%BD%E7%82%B9%E5%90%8D%E5%8D%95/%E6%88%AA%E5%B1%8F3.png"><br>在此目录下打开命令窗口输入<code> java -jar CreateList.jar</code>,即可输出名单。<br><img src="/img/%E7%94%9F%E6%88%90%E6%8A%BD%E7%82%B9%E5%90%8D%E5%8D%95/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="三、Github仓库地址及commit记录。"><a href="#三、Github仓库地址及commit记录。" class="headerlink" title="三、Github仓库地址及commit记录。"></a>三、Github仓库地址及commit记录。</h3><p><a href="https://github.com/casual-qian/second_teamwork">地址</a><br><img src="/img/%E7%94%9F%E6%88%90%E6%8A%BD%E7%82%B9%E5%90%8D%E5%8D%95/commit%E8%AE%B0%E5%BD%95.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识MySQL</title>
    <link href="/2022/10/15/%E5%88%9D%E8%AF%86MySQL/"/>
    <url>/2022/10/15/%E5%88%9D%E8%AF%86MySQL/</url>
    
    <content type="html"><![CDATA[<p>所有的网络应用都有基于数据的操作，数据的安全存储就靠数据库了，所以数据库在网络应用中的重要性是不言而喻的，一般在企业里进行开发都会使用到MySQL数据库，所以在之后我们将详细的学习MySQL数据库的用法。</p><p>MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。</p><p>由于MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。</p><p>MySQL这个名字，起源不是很明确。一个比较有影响的说法是，基本指南和大量的库和工具带有前缀“my”已经有10年以上，而且不管怎样，MySQL AB创始人之一的Monty Widenius的女儿也叫My。这两个到底是哪一个给出了MySQL这个名字至今依然是个迷，包括开发者在内也不知道。</p><p>MySQL的海豚标志的名字叫“sakila”，它是由MySQL AB的创始人从用户在“海豚命名”的竞赛中建议的大量的名字表中选出的。获胜的名字是由来自非洲斯威士兰的开源软件开发者Ambrose Twebaze提供。根据Ambrose所说，Sakila来自一种叫SiSwati的斯威士兰方言，也是在Ambrose的家乡乌干达附近的坦桑尼亚的Arusha的一个小镇的名字。<br>MySQL，虽然功能未必很强大，但因为它的开源、广泛传播，导致很多人都了解到这个数据库。它的历史也富有传奇性。</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h3 id="一、连接数据库"><a href="#一、连接数据库" class="headerlink" title="一、连接数据库"></a>一、连接数据库</h3><p>输入命令：mysql -u用户名 -p密码<br>在平台上连接数据库：mysql -u用户名 -p密码 -h127.0.0.1</p><h3 id="二、创建数据库"><a href="#二、创建数据库" class="headerlink" title="二、创建数据库"></a>二、创建数据库</h3><p>连接上MySQL后就可以进行数据库的操作了，接下来我们创建一个名为TestDb的数据库：<br><img src="https://img-blog.csdnimg.cn/img_convert/da3f5054ad4e0948e5f935614c9244d6.png"><br>创建完数据库之后我们可以通过show databases;命令查看MySQL中已存在的数据库。<br><img src="https://img-blog.csdnimg.cn/img_convert/051b0e0a47a92e0f65eaccff8972c388.png"></p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p><strong>【注】在MySQL数据库中是不区分大小写的</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/8d352209b2ffa90e060bfccbd867081e.png"></p><h3 id="一、创建数据库"><a href="#一、创建数据库" class="headerlink" title="一、创建数据库"></a>一、创建数据库</h3><p>CREATE DATABASE MyDb;</p><h3 id="二、选择数据库"><a href="#二、选择数据库" class="headerlink" title="二、选择数据库"></a>二、选择数据库</h3><p>USE MyDb;</p><h3 id="三、创建t-user表"><a href="#三、创建t-user表" class="headerlink" title="三、创建t_user表"></a>三、创建t_user表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_user<br>(<br>  id <span class="hljs-type">INT</span>,<br>  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>  <span class="hljs-keyword">password</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>  phone <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">11</span>)<br>);<br></code></pre></td></tr></table></figure><h2 id="使用主键约束"><a href="#使用主键约束" class="headerlink" title="使用主键约束"></a>使用主键约束</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>是表中一列或者多列的组合，主键约束（Primary Key Constraint）要求主键列的数据唯一，并且不允许为空，主键能够唯一的标识表中的每一条记录，可以结合外键来定义与不同数据表之间的关系。<br>怎么理解主键呢？我们知道数据库中的表可以存放很多数据，如果把表中的每一个数据比作一个人的话，那么<strong>表的主键</strong>就可以看做是<strong>人的身份证</strong>。</p><h4 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h4><p>有两种方式可以添加主键约束：<br>1.在定义列的同时指定主键；<br>2.在定义完字段之后再指定主键。</p><p>(1) 在定义列的同时指定主键：<br><img src="https://img-blog.csdnimg.cn/img_convert/46a7a19720362ba753f8bd30a95a0aaa.png"><br>(2) 在定义完所有列之后指定主键。<br><img src="https://img-blog.csdnimg.cn/img_convert/b190a25f95105153b3a0ee2c12c223ca.png"></p><h4 id="多字段联合主键"><a href="#多字段联合主键" class="headerlink" title="多字段联合主键"></a>多字段联合主键</h4><p>在开发中还有一种情况很常见，就是将几个字段联合在一起作为主键，那这个在代码中怎么实现呢？<br>举个例子，我们将员工的名字和部门ID联合起来作为主键：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_emp2<br>(<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>deptId <span class="hljs-type">INT</span>,<br>salary <span class="hljs-type">FLOAT</span>,<br><span class="hljs-keyword">PRIMARY KEY</span>(<span class="hljs-type">name</span>,deptId)<br>)<br></code></pre></td></tr></table></figure><p>语句执行后，会将name和deptId字段组合成为表t_emp2的多字段组合主键。</p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="外部关键字"><a href="#外部关键字" class="headerlink" title="外部关键字"></a>外部关键字</h3><p>在以后我们统一将外部关键字叫做外键，外键就是另一张表中的主键。</p><p><strong>问</strong>：外键有啥用啊？<br><strong>答</strong>：外键的主要作用就是保持数据的一致性，完整性。</p><p><strong>再问</strong>：怎么保证的呢？<br><strong>答</strong>：看图。<br><img src="https://img-blog.csdnimg.cn/img_convert/55d3d471d89158367f4d8a098312b5c3.png"><br>如图有两张表，classId 是T_Student的外键，是T_class 表的主键， 如果我们要删除T_class 表中classId为1的字段，程序是会<strong>报错</strong>的，因为t_student表中有数据和classId为1的字段关联了，是不能删除的，这样子就保证了数据的<strong>一致性和完整性</strong>。</p><p><strong>继续问</strong>：那怎么才能删除呢？<br><strong>接着答</strong>：需要先删除T__student表中classId为1的两个字段。</p><p>如何给表添加外部关键字</p><p>在MySQL中给表中字段添加外键约束的语法规则如下：</p><p>CONSTRAINT 外键名 FOREIGN KEY 字段名 REFERENCES 主表名(主键名)<br>举个例子：现在有两张表，t_emp、t_dept如下。</p><p>t_dept表</p><table><thead><tr><th><strong>字段名称</strong></th><th><strong>数据类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>deptId</td><td>INT</td><td>部门编号</td></tr><tr><td>name</td><td>VARCHAR(22)</td><td>部门名称</td></tr><tr><td>location</td><td>VARCHAR(50)</td><td>部门位置</td></tr></tbody></table><p>t_emp表</p><table><thead><tr><th><strong>字段名称</strong></th><th><strong>数据类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>员工编号</td></tr><tr><td>name</td><td>VARCHAR(22)</td><td>员工姓名</td></tr><tr><td>deptId</td><td>INT</td><td>部门ID(外键类型必须和对应主键类型一直)</td></tr></tbody></table><p>我们来创建两张表，并给员工表(t_emp)添加外键：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_dept<br>(<br>deptId <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>),<br><span class="hljs-keyword">location</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_emp<br>(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>),<br>deptId <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">CONSTRAINT</span> fk_emp_dept1 <span class="hljs-keyword">FOREIGN KEY</span>(deptId) <span class="hljs-keyword">REFERENCES</span> t_dept(deptId)<br>);<br></code></pre></td></tr></table></figure><p>实际操作如图：<br><img src="https://img-blog.csdnimg.cn/img_convert/faef997fedf7605b9d6905e243a3db5f.png"></p><h2 id="添加常用约束"><a href="#添加常用约束" class="headerlink" title="添加常用约束"></a>添加常用约束</h2><p>在数据库的使用过程中我们经常要限制字段的取值，比如有些字我们不能让它为空，我们就需要添加非空约束。</p><h3 id="怎么添加唯一约束"><a href="#怎么添加唯一约束" class="headerlink" title="怎么添加唯一约束"></a>怎么添加唯一约束</h3><p>唯一约束（Unique Constraint）要求该列唯一，允许为空，但是只能有一个空值。唯一约束可以确保一列或者几列不出现重复值。</p><p>定义部门表的部门名称唯一，SQL语句如下：关键词 UNIQUE。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_dept(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>) <span class="hljs-keyword">UNIQUE</span>,<br><span class="hljs-keyword">location</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="怎么添加非空约束"><a href="#怎么添加非空约束" class="headerlink" title="怎么添加非空约束"></a>怎么添加非空约束</h3><p>关键词：NOT NULL；</p><p>例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_dept(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">location</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="怎么使用默认约束"><a href="#怎么使用默认约束" class="headerlink" title="怎么使用默认约束"></a>怎么使用默认约束</h3><p>默认约束：即给字段一个默认值。<br>关键词：DEFAULT；</p><p>例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_emp(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>),<br>sex <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;男&#x27;</span><br>) <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>如果是添加字符串型默认值要使用单引号，如果是整型则不需要加任何符号；</li><li>如果要添加的是中文默认值，则需要加上DEFAULT CHARSET&#x3D;utf8;使用英文字符则不需要。<br>设置表的属性值自动增加</li></ul><p>在数据库应用中，经常有个需求就是，在每次插入新纪录时，系统自动生成字段的主键值，即：</p><table><thead><tr><th><strong>id</strong></th><th><strong>name</strong></th></tr></thead><tbody><tr><td>1</td><td>张三</td></tr><tr><td>2</td><td>李四</td></tr><tr><td>ID每次自动加一</td><td>姓名</td></tr><tr><td>…</td><td>XXX</td></tr><tr><td>10</td><td>XXX</td></tr></tbody></table><p>关键词：AUTO_INCREMENT，默认情况下初始值和增量都为1。</p><p>例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_tmp<br>(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>)<br>)<br></code></pre></td></tr></table></figure><p>编程要求</p><p>在数据库MyDb中创建表t_user，表结构如下：</p><table><thead><tr><th>字段名称</th><th>数据类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>用户ID，主键，自动增长</td></tr><tr><td>username</td><td>varchar(32)</td><td>用户名，非空，唯一</td></tr><tr><td>sex</td><td>varchar(4)</td><td>性别，默认“男”</td></tr></tbody></table><p>提示：若要给字段添加两个或者两个以上的约束，约束之间以空格隔开即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程通信</title>
    <link href="/2022/10/15/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/10/15/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>Linux 作为一个多任务多进程的操作系统，各个进程间信息交互<br>不可避免，进程间通信可分为本地进程间通信和远程进程间通信。本地进<br>程间通信主要包括信号，管道，消息队列，信号量，共享内存等通信方式。</p><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*使用命名管道FIFO机制实现客户到服务器之间传递数据的操作。多客户-单一服务器模式*/</span><br><span class="hljs-regexp">/*命名管道文件需创建在Linux文件系统内*/</span><br><span class="hljs-regexp">/*在一个终端窗口中运行fifo-server程序，然后在另外一个终端窗口运行fifo-client程序*/</span><br><br><span class="hljs-regexp">/*fifo-server.c */</span><br><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;linux/stat.h&gt;</span><br><br><span class="hljs-comment">#define FIFO_FILE &quot;/tmp/MYFIFO&quot; /*命名管道的路径、文件名*/</span><br><br>int main()<br>&#123;<br>FILE *fp;<br>char readbuf[<span class="hljs-number">80</span>];<br><br><span class="hljs-keyword">if</span>((fp=fopen(FIFO_FILE,<span class="hljs-string">&quot;r&quot;</span>))==NULL)<span class="hljs-regexp">/*如果命名管道文件不存在，要先创建一个*/</span><br>&#123;<br>umask(<span class="hljs-number">0</span>);<span class="hljs-regexp">//</span>清除文件创建时权限位的屏蔽作用<br>mknod(FIFO_FILE,S_IFIFO|<span class="hljs-number">0666</span>,<span class="hljs-number">0</span>);<span class="hljs-regexp">//</span>创建FIFO文件<br>printf(<span class="hljs-string">&quot;create new fifo successed. \n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br> fclose(fp);<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span>((fp=fopen(FIFO_FILE,<span class="hljs-string">&quot;r&quot;</span>))==NULL)<span class="hljs-regexp">/*打开命名管道文件*/</span><br> &#123;<br>printf(<span class="hljs-string">&quot;open fifo failed. \n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>(fgets(readbuf,<span class="hljs-number">80</span>,fp)!=NULL)<span class="hljs-regexp">/*从命名管道文件中读数据*/</span><br>&#123;<br>printf(<span class="hljs-string">&quot;Received string :%s \n&quot;</span>, readbuf);<br>fclose(fp);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(ferror(fp))<br>&#123;<br>printf(<span class="hljs-string">&quot;read fifo failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*使用命名管道FIFO机制实现客户到服务器之间传递数据的操作。多客户-单一服务器模式*/</span><br><span class="hljs-regexp">/*命名管道文件需创建在Linux文件系统内*/</span><br><span class="hljs-regexp">/*在一个终端窗口中运行fifo-server程序，然后在另外一个终端窗口运行fifo-client程序*/</span><br><br><span class="hljs-regexp">/*fifo-client.c */</span><br><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><br><span class="hljs-comment">#define FIFO_FILE &quot;/tmp/MYFIFO&quot;/*命名管道的路径、文件名*/</span><br><br>int main(int argc, char *argv[])<br>&#123;<br>FILE *fp;<br>int i;<br><span class="hljs-keyword">if</span>(argc&lt;=<span class="hljs-number">1</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;usage: %s &lt;message&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br> <br><span class="hljs-keyword">if</span>((fp=fopen(FIFO_FILE,<span class="hljs-string">&quot;w&quot;</span>))==NULL)<span class="hljs-regexp">/*打开命名管道文件*/</span><br>&#123;<br>printf(<span class="hljs-string">&quot;open fifo failed. \n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;argc;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(fputs(argv[i],fp)==EOF)<br>&#123;<br>printf(<span class="hljs-string">&quot;write fifo error. \n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(fputs(<span class="hljs-string">&quot; &quot;</span>,fp)==EOF)<br>&#123;<br>printf(<span class="hljs-string">&quot;write fifo error. \n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>fclose(fp);<br>return <span class="hljs-number">0</span>;<br> <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>发送端</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*使用消息队列机制实现发送接收消息的操作。*/</span><br><span class="hljs-comment">/*在一个终端窗口中运行msg-send程序，然后在另外一个终端窗口运行msg-recieve程序*/</span><br><br><span class="hljs-comment">/*msg-send.c */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_msg</span><span class="hljs-comment">//消息的组成</span><br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> my_msg_type;<span class="hljs-comment">//消息的类型域</span><br><span class="hljs-type">char</span> text[BUFSIZ];<span class="hljs-comment">//消息传递的数据域</span><br>&#125; msgbuf;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> running =<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> msgid;<br>msgid=<span class="hljs-built_in">msgget</span>((<span class="hljs-type">key_t</span>)<span class="hljs-number">1234</span>,<span class="hljs-number">0666</span> |IPC_CREAT);<span class="hljs-comment">//打开key值为1234的消息队列，如不存在则创建之</span><br><span class="hljs-keyword">if</span>(msgid==<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgget failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">while</span>(running)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter some text: &quot;</span>);<br><span class="hljs-built_in">fgets</span>(msgbuf.text,BUFSIZ,stdin);<span class="hljs-comment">//读入键盘输入的消息</span><br>msgbuf.my_msg_type=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">msgsnd</span>(msgid,(<span class="hljs-type">void</span> *)&amp;msgbuf, BUFSIZ, <span class="hljs-number">0</span>)==<span class="hljs-number">-1</span>)<span class="hljs-comment">//发送消息</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgsnd failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(msgbuf.text,<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-number">3</span>)==<span class="hljs-number">0</span>)<span class="hljs-comment">//输入end表示程序结束</span><br>running=<span class="hljs-number">0</span>;<br>&#125;<br>       <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接收端</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*使用消息队列机制实现发送接收消息的操作。*/</span><br><span class="hljs-comment">/*在一个终端窗口中运行msg-send程序，然后在另外一个终端窗口运行msg-recieve程序*/</span><br><br><span class="hljs-comment">/*msg-recieve.c */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_msg</span><span class="hljs-comment">//消息的组成</span><br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> my_msg_type;<span class="hljs-comment">//消息的类型域</span><br><span class="hljs-type">char</span> text[BUFSIZ];<span class="hljs-comment">//消息传递的数据域</span><br>&#125; msgbuf;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> running =<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> msgid;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> msg_to_receive=<span class="hljs-number">0</span>;<br>msgid=<span class="hljs-built_in">msgget</span>((<span class="hljs-type">key_t</span>)<span class="hljs-number">1234</span>,<span class="hljs-number">0666</span> |IPC_CREAT);<span class="hljs-comment">//打开key值为1234的消息队列，如不存在则创建之</span><br><span class="hljs-keyword">if</span>(msgid==<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgget failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">while</span>(running)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">msgrcv</span>(msgid,(<span class="hljs-type">void</span> *)&amp;msgbuf, BUFSIZ,msg_to_receive, <span class="hljs-number">0</span>)==<span class="hljs-number">-1</span>)<span class="hljs-comment">//接收消息</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgrcv failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You wrote : %s&quot;</span>, msgbuf.text);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(msgbuf.text,<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-number">3</span>)==<span class="hljs-number">0</span>)<span class="hljs-comment">//收到end表示程序结束</span><br>running=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">msgctl</span>(msgid, IPC_RMID, <span class="hljs-number">0</span>)==<span class="hljs-number">-1</span>)<span class="hljs-comment">//删除消息队列</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgct(IPC_RMID)  failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>写入端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*使用共享内存机制实现通信*/</span><br><span class="hljs-regexp">/*在一个终端窗口中先运行shm-write程序，然后在另外一个终端窗口运行shm-read程序*/</span><br><br><span class="hljs-regexp">/*shm-write.c */</span><br><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/ipc.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/shm.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;string.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><br>int main()<br>&#123;<br>int shmid;<br>char c;<br>char *shmptr, *s;<br><span class="hljs-keyword">if</span>((shmid=shmget(<span class="hljs-number">1234</span>,<span class="hljs-number">256</span>,IPC_CREAT | <span class="hljs-number">0666</span>))&lt;<span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>打开key值为<span class="hljs-number">1234</span>的共享内存，如不存在则创建之<br>&#123;<br>printf(<span class="hljs-string">&quot;shmget failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>((shmptr=shmat(shmid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))==(char*)-<span class="hljs-number">1</span>)<span class="hljs-regexp">//</span>附加此共享内存至自己的地址空间，返回内存区域的指针<br>&#123;<br>shmctl(shmid, IPC_RMID, (struct shmid_ds*)shmptr);<br>printf(<span class="hljs-string">&quot;shmat failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">2</span>);<br>&#125;<br>s=shmptr;<span class="hljs-regexp">//</span> 写共享内存通过指针s操作<br><span class="hljs-keyword">for</span>(c=<span class="hljs-string">&#x27;a&#x27;</span>;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;c++)<span class="hljs-regexp">//</span>写入<span class="hljs-number">26</span>个字母<br>*s++=c;<br>s=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-keyword">while</span>(*shmptr!=<span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-regexp">//</span>等待直到读进程已写入“*”表示读完数据<br>sleep(<span class="hljs-number">1</span>);<br>shmctl(shmid, IPC_RMID, (struct shmid_ds*)shmptr);<span class="hljs-regexp">//</span>删除共享内存<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*使用共享内存机制实现通信*/</span><br><span class="hljs-regexp">/*在一个终端窗口中先运行shm-write程序，然后在另外一个终端窗口运行shm-read程序*/</span><br><br><span class="hljs-regexp">/*shm-read.c */</span><br><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/ipc.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/shm.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;string.h&gt;</span><br><br>int main()<br>&#123;<br><br>int shmid;<br>char c;<br>char*shmptr, *s;<br><span class="hljs-keyword">if</span>((shmid=shmget(<span class="hljs-number">1234</span>,<span class="hljs-number">256</span>, <span class="hljs-number">0666</span>))&lt;<span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>打开key值为<span class="hljs-number">1234</span>的共享内存<br>&#123;<br>printf(<span class="hljs-string">&quot;shmget failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>((shmptr=shmat(shmid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))==(char*)-<span class="hljs-number">1</span>)<span class="hljs-regexp">//</span>附加此共享内存至自己的地址空间<br>&#123;<br>shmctl(shmid,IPC_RMID,(struct shmid_ds*)shmptr);<br>printf(<span class="hljs-string">&quot;shmat failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(s=shmptr;*s!=<span class="hljs-string">&#x27;\0&#x27;</span>;s++)<span class="hljs-regexp">//</span>读出<span class="hljs-number">26</span>个字母<br>putchar(*s);<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>*shmptr=<span class="hljs-string">&#x27;*&#x27;</span>;<span class="hljs-regexp">//</span>写入“*”到共享内存表示读完数据<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>头文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*共享内存机制可以直接读取内存，所以其通信效率高于管道和消息队列*/</span><br><span class="hljs-comment">/*由于多个进程对同一块内存区域具有访问的权限，进程之间的同步就非常重要*/</span><br><span class="hljs-comment">/*使用信号量机制PV操作来同步的共享内存机制通信*/</span><br><span class="hljs-comment">/*在一个终端窗口中先运行semshm-write程序，然后在另外一个终端窗口运行semshm-read程序*/</span><br><br><span class="hljs-comment">/*semshm-.h */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;error.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHM_SIZE     1024</span><br><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">semun</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">semid_ds</span> *buf;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *array;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">seminfo</span> *buf_info;<br>    <span class="hljs-type">void</span> *pad;<br>&#125;;<br><br><span class="hljs-comment">/* 创建信号量函数*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creatsem</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id, <span class="hljs-type">int</span> members, <span class="hljs-type">int</span> init_val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">key_t</span> msgkey;<br>    <span class="hljs-type">int</span> index, sid;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">semun</span> semopts;<br>    <br>    <span class="hljs-keyword">if</span>((msgkey = <span class="hljs-built_in">ftok</span>(pathname, proj_id)) == <span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//利用ftok函数生成键值，自行指定的键值可能会冲突</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ftok error!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((sid = <span class="hljs-built_in">semget</span>(msgkey, members, IPC_CREAT|<span class="hljs-number">0666</span>)) == <span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//打开键值为msgkey的信号量集，如不存在则创建之，返回信号量集标识符。members为信号量集中含信号量的数目。</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semget call failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    semopts.val = init_val;<br>    <span class="hljs-keyword">for</span>(index = <span class="hljs-number">0</span>; index &lt; members; index++)&#123;<br>        <span class="hljs-built_in">semctl</span>(sid, index, SETVAL, semopts);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sid;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">opensem</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">key_t</span> msgkey;<br>    <span class="hljs-type">int</span> sid;<br>    <br>    <span class="hljs-keyword">if</span>((msgkey = <span class="hljs-built_in">ftok</span>(pathname, proj_id)) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ftok error!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>((sid = <span class="hljs-built_in">semget</span>(msgkey, <span class="hljs-number">0</span>, <span class="hljs-number">0666</span>)) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open semget call failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sid;<br>&#125;<br><br><span class="hljs-comment">/* p操作, 获取信号量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_p</span><span class="hljs-params">(<span class="hljs-type">int</span> semid, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> sbuf = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, IPC_NOWAIT&#125;;<span class="hljs-comment">//每个sembuf结构描述了一个对信号量的操作</span><br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;index of array cannot equals a minus value!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sbuf.sem_num = index;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">semop</span>(semid, &amp;sbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;A wrong operation to semaphore occurred!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* V操作, 释放信号量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_v</span><span class="hljs-params">(<span class="hljs-type">int</span> semid, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> sbuf = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, IPC_NOWAIT&#125;;<span class="hljs-comment">//每个sembuf结构描述了一个对信号量的操作</span><br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;index of array cannot equals a minus value!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sbuf.sem_num = index;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">semop</span>(semid, &amp;sbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;A wrong operation to semaphore occurred!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 删除信号量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_delete</span><span class="hljs-params">(<span class="hljs-type">int</span> semid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">semctl</span>(semid, <span class="hljs-number">0</span>, IPC_RMID));<br>&#125;<br><br><span class="hljs-comment">/* 等待信号量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wait_sem</span><span class="hljs-params">(<span class="hljs-type">int</span> semid, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">semctl</span>(semid, index, GETVAL, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">500</span>);<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>&#125;<br><br><span class="hljs-comment">/* 创建共享内存*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creatshm</span><span class="hljs-params">(<span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id, <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">key_t</span> shmkey;<br>    <span class="hljs-type">int</span> sid;<br>    <br>    <span class="hljs-keyword">if</span>((shmkey = <span class="hljs-built_in">ftok</span>(pathname, proj_id)) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ftok error!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((sid = <span class="hljs-built_in">shmget</span>(shmkey, size, IPC_CREAT|<span class="hljs-number">0666</span>)) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;shm call failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sid;<br>&#125;<br><br><span class="hljs-comment">/* 删除共享内存*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteshm</span><span class="hljs-params">(<span class="hljs-type">int</span> sid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">void</span> *p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">shmctl</span>(sid, IPC_RMID, p));<br>&#125;<br></code></pre></td></tr></table></figure><p>写入端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*共享内存机制可以直接读取内存，所以其通信效率高于管道和消息队列*/</span><br><span class="hljs-regexp">/*由于多个进程对同一块内存区域具有访问的权限，进程之间的同步就非常重要*/</span><br><span class="hljs-regexp">/*使用信号量机制PV操作来同步的共享内存机制通信*/</span><br><span class="hljs-regexp">/*在一个终端窗口中先运行semshm-write程序，然后在另外一个终端窗口运行semshm-read程序*/</span><br><br><span class="hljs-regexp">/*semshm-write.c */</span><br><br><span class="hljs-comment">#include &quot;2-4semshm-.h&quot;</span><br><br>int main(int argc, char** argv)<br>&#123;<br>    int semid, shmid;<br>    char *shmaddr;<br>    char write_str[SHM_SIZE];<br>    char *ret;<br>    <span class="hljs-keyword">if</span>((shmid = creatshm(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">57</span>, SHM_SIZE)) == -<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span>创建或者获取共享内存<br>        return -<span class="hljs-number">1</span>;<br><span class="hljs-regexp">/*建立进程和共享内存连接*/</span><br>    <span class="hljs-keyword">if</span>((shmaddr = shmat(shmid, (char*)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) == (char *)-<span class="hljs-number">1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;attch shared memory error!\n&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;    <br>    <span class="hljs-keyword">if</span>((semid = creatsem(<span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-number">39</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)) == -<span class="hljs-number">1</span>)<span class="hljs-regexp">//</span>创建信号量<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        wait_sem(semid, <span class="hljs-number">0</span>);<span class="hljs-regexp">//</span>等待信号量可以被获取<br>        sem_p(semid, <span class="hljs-number">0</span>);  <span class="hljs-regexp">//</span>获取信号量<br><span class="hljs-regexp">/***************写共享内存***************************************************/</span><br>        printf(<span class="hljs-string">&quot;write : &quot;</span>);<br>        ret = fgets(write_str, <span class="hljs-number">1024</span>, stdin);<br>        <span class="hljs-keyword">if</span>(write_str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;#&#x27;</span>结束读写进程<br>            <span class="hljs-keyword">break</span>;<br>        int len = strlen(write_str);<br>        write_str[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        strcpy(shmaddr, write_str);<br><span class="hljs-regexp">/****************************************************************************/</span><br>        sem_v(semid, <span class="hljs-number">0</span>); <span class="hljs-regexp">//</span>释放信号量<br>        usleep(<span class="hljs-number">1000</span>);  <span class="hljs-regexp">//</span>本进程睡眠.<br>    &#125;<br>    sem_delete(semid); <span class="hljs-regexp">//</span>把semid指定的信号集从系统中删除<br>    deleteshm(shmid);   <span class="hljs-regexp">//</span>从系统中删除shmid标识的共享内存<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*共享内存机制可以直接读取内存，所以其通信效率高于管道和消息队列*/</span><br><span class="hljs-regexp">/*由于多个进程对同一块内存区域具有访问的权限，进程之间的同步就非常重要*/</span><br><span class="hljs-regexp">/*使用信号量机制PV操作来同步的共享内存机制通信*/</span><br><span class="hljs-regexp">/*在一个终端窗口中先运行semshm-write程序，然后在另外一个终端窗口运行semshm-read程序*/</span><br><br><span class="hljs-regexp">/*semshm-read.c */</span><br><br><span class="hljs-comment">#include &quot;2-4semshm-.h&quot;</span><br><br>int main(int argc, char** argv)<br>&#123;<br>    int semid, shmid;<br>    char *shmaddr;<br>    <span class="hljs-keyword">if</span>((shmid = creatshm(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">57</span>, SHM_SIZE)) == -<span class="hljs-number">1</span>)<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>((shmaddr = shmat(shmid, (char*)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) == (char *)-<span class="hljs-number">1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;attch shared memory error!\n&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>((semid = opensem(<span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-number">39</span>)) == -<span class="hljs-number">1</span>)<br>        return -<span class="hljs-number">1</span>;<br>    printf(<span class="hljs-string">&quot;read start....................\n&quot;</span>);        <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        printf(<span class="hljs-string">&quot;read : &quot;</span>);<br>        wait_sem(semid, <span class="hljs-number">0</span>);  <span class="hljs-regexp">//</span>等待信号量可以获取<br>        <span class="hljs-keyword">if</span>(sem_p(semid, <span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span>获取信号量失败退出。当server写入<span class="hljs-string">&#x27;#&#x27;</span>时引发<br>            <span class="hljs-keyword">break</span>;<br>        printf(<span class="hljs-string">&quot;%s&quot;</span>, shmaddr);<br><br>        sem_v(semid, <span class="hljs-number">0</span>);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;    <br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程管理</title>
    <link href="/2022/10/08/LInux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2022/10/08/LInux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、fork函数"><a href="#一、fork函数" class="headerlink" title="一、fork函数"></a>一、fork函数</h3><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>当程序执行到fork函数时会复制一份原来的进程（创建一个新的进程），旧进程（父进程）和新进程（子进程）会继续执行fork之后的代码,父子进程执行的顺序未知。</p><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*简单了解fork函数的功能*/</span><br><span class="hljs-comment">/*父进程与子进程的执行顺序未知*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> flag;<span class="hljs-comment">//flag用于区别创建的子进程</span><br>flag = fork();<span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//子进程child_1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is child_1 process %d\n&quot;</span>,flag);<br>flag++;<br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) <span class="hljs-comment">//在子进程下创建新的子进程child_2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is child process of child_1\n&quot;</span>);<br><span class="hljs-comment">//进程 child_1</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is child_1 process %d\n&quot;</span>,flag);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//父进程</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is parent process\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/fork%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="二、exec函数族"><a href="#二、exec函数族" class="headerlink" title="二、exec函数族"></a>二、exec函数族</h3><h4 id="功能说明-1"><a href="#功能说明-1" class="headerlink" title="功能说明"></a>功能说明</h4><p>fork()函数通过系统调用创建一个与原来进程（父进程）几乎完全相同的进程（子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程不共享这些存储空间。linux将复制父进程的地址空间内容给子进程，因此，子进程由了独立的地址空间。），也就是这两个进程做完全相同的事。</p><p>正因为fork函数创建的子进程几乎等同于父进程的副本，所以我们更希望子进程可以执行不一样的操作，可以装入和运行其它程序（子进程替换原有进程，和父进程做不同的事）,使用exec函数就可以执行和父进程不一样的操作。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><table>    <tr>        <td>头文件</td>        <td>#include &#60unistd&#62</td>      </tr>    <tr>        <td>函数说明</td>        <td>执行文件</td>    </tr>    <tr>        <td rowspan="6">函数原型</td>        <td>int execl(const char *pathname, const char *arg, ...)</td>    </tr>    <tr>        <td>int execv(const char *pathname, char *const argv[])</td>    </tr>    <tr>        <td>int execle(const char *pathname, const char *arg, ..., char *const envp[])</td>    </tr>    <tr>        <td>int execve(const char *pathname, char *const argv[], char *const envp[])</td>    </tr>    <tr><td>int execvp(const char *filename, char *const argv[])</td>    </tr>    <tr>        <td>int execlp(const char *filename, const char *arg, ...)</td>    </tr>    <tr>        <td rowspan="2">函数返回值</td>        <td>成功：函数不会返回</td>    </tr>    <tr>        <td>出错：返回-1，失败原因记录在error中</td>    </tr></table><h4 id="命名语法"><a href="#命名语法" class="headerlink" title="命名语法"></a>命名语法</h4><table>    <tr>        <td>前4位</td>        <td colspan="2">统一为：exec</td>    </tr>    <tr>        <td rowspan="2">第5位</td>        <td>l：参数传递为逐个列举方式</td>        <td>execl、execle、execlp</td>    </tr>    <tr>        <td>v：参数传递为构造指针数组方式</td>        <td>execv、execve、execvp</td>    </tr>    <tr>        <td rowspan="2">第6位</td>        <td>e：可传递新进程环境变量</td>        <td>execle、execve</td>    </tr>    <tr>        <td>p：可执行文件查找方式为文件名</td>        <td>execlp、execvp</td>    </tr></table><h5 id="简单例子-1"><a href="#简单例子-1" class="headerlink" title="简单例子"></a>简单例子</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*程序执行execlp函数和execv函数*/</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br>int main()<br>&#123;<br>pid_t pid;<br><br><span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>创建子进程child_1<br>&#123;<br><span class="hljs-regexp">//</span>错误处理<br>perror(<span class="hljs-string">&quot;fork&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-regexp">//</span>子进程child_1<br>printf(<span class="hljs-string">&quot;\nThis is child_1 process\n&quot;</span>);<br><span class="hljs-keyword">if</span>(execlp(<span class="hljs-string">&quot;pwd&quot;</span>,<span class="hljs-string">&quot;pwd&quot;</span>,NULL) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>转入执行pwd命令<br>&#123;<br>perror(<span class="hljs-string">&quot;execlp&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>printf(<span class="hljs-string">&quot;never be displayed&quot;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span>创建以NULL结尾的字符串数组指针以便execv函数使用<br>char *arg[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>,NULL&#125;;<br><span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>创建子进程child_2<br>&#123;<br>perror(<span class="hljs-string">&quot;fork&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-regexp">//</span>子进程child_2<br>printf(<span class="hljs-string">&quot;\nThis is child_2 process\n&quot;</span>);<br><span class="hljs-keyword">if</span>(execv(<span class="hljs-string">&quot;/bin/ls&quot;</span>,arg) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>转入执行ls命令<br>&#123;<br>perror(<span class="hljs-string">&quot;execv&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>printf(<span class="hljs-string">&quot;never be displayed&quot;</span>);<br>&#125;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/exec%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="三、singal函数"><a href="#三、singal函数" class="headerlink" title="三、singal函数"></a>三、singal函数</h3><h4 id="功能说明-2"><a href="#功能说明-2" class="headerlink" title="功能说明"></a>功能说明</h4><p>通过signal函数可以设置系统对于某一信号的对应的操作<br>所在函数库：#include &lt;signal.h&gt;<br>使用原型：signal(int signum,sighandler_t handler)<br>参数说明：<br>signum：信号编号<br>handler的取值：<br>忽略该信号：SIG_IGN<br>执行系统默认动作：SIG_DFL<br>自定义信号处理函数：信号处理函数名</p><h4 id="简单例子-2"><a href="#简单例子-2" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-comment">//注册printsignum函数以便使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printsignum</span><span class="hljs-params">(<span class="hljs-type">int</span> SignNum)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The signal number is %d\n&quot;</span>,SignNum);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a process\n&quot;</span>);<br><span class="hljs-built_in">signal</span>(SIGINT,printsignum);<span class="hljs-comment">//注册SIGINT信号,键接收到该信号后会执行printsignum函数</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//键入ctrl+c 执行pirntsignum函数</span><br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Never be displayed\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/signal%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="四、make函数的使用"><a href="#四、make函数的使用" class="headerlink" title="四、make函数的使用"></a>四、make函数的使用</h3><h4 id="功能说明-3"><a href="#功能说明-3" class="headerlink" title="功能说明"></a>功能说明</h4><p>使用make命令，系统会在当前目录下寻找Makefile的文件，并对它进行解释，处理，并执行相关动作。</p><h4 id="简单例子-3"><a href="#简单例子-3" class="headerlink" title="简单例子"></a>简单例子</h4><p>主程序main通过调用函数function_A执行相关操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//主函数中调用函数function_A</span><br><span class="hljs-built_in">function_A</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数function_A在同一目录下的另一c文件function_A.c中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_A</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//输出相关文字</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is function_A\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在同一目录下的makefile文件内容如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">all:</span> main.<span class="hljs-keyword">c</span> function_A.<span class="hljs-keyword">c</span><br>gcc -o all main.<span class="hljs-keyword">c</span> function_A.<span class="hljs-keyword">c</span> #次行以tab开头<br></code></pre></td></tr></table></figure><p>在此目录下键入make命令，发现目录下生成了名为all的可执行文件，执行这个文件，观察到所需的操作已经执行，结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/make%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识原型设计</title>
    <link href="/2022/10/02/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/10/02/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="事先说明"><a href="#事先说明" class="headerlink" title="事先说明"></a>事先说明</h3><p>其实主要是设计方面，个人艺术细胞不太好，没有美观的界面，只是设计了一个模型出来，无法实现其功能，这次是两人结队完成的哦</p><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><h4 id="1-Need-需求"><a href="#1-Need-需求" class="headerlink" title="1.Need 需求"></a>1.Need 需求</h4><ul><li>班级名单导入或生成，要方便易用</li><li>班级点名方式要方便易用</li><li>班级点名方式要尽可能防作弊</li><li>要支持多班级功能</li><li>要支持期末汇总统计导出</li><li>要支持请假功能</li><li>要符合小程序的规范的界面或功能要求</li></ul><h4 id="2-Approach-做法"><a href="#2-Approach-做法" class="headerlink" title="2.Approach 做法"></a>2.Approach 做法</h4><p>（1）使用原型设计工具墨刀设计基于微信小程序的课堂签到小程序；<br>（2）学生端实现学生的课堂签到、签到记录查询；<br>（3）教师端支持发布签到、管理班级、导出名单等功能。</p><h4 id="3-Benefit-好处"><a href="#3-Benefit-好处" class="headerlink" title="3.Benefit 好处"></a>3.Benefit 好处</h4><p>（1）采用分模块、分层次实现，UI简洁明了，方便用户使用；<br>（2）不同的身份定位提供不同的服务；<br>（3）采用扫码加定位签到方式，在一定程度上防止作弊.</p><h4 id="4-Competitors-竞争"><a href="#4-Competitors-竞争" class="headerlink" title="4.Competitors 竞争"></a>4.Competitors 竞争</h4><p>经调研，在本校内师生大多数使用“e点课堂”以及“雨课堂”两款小程序。其中e点并不支持教师导入导出班级成员名单，且仅采用扫码方式进行签到，缺乏有效防作弊手段；雨课堂虽然提供了共享课件以及课堂互动特色功能，但在签到功能需求上采用扫码或课堂码方式签到，也是缺乏有效防作弊手段，且两者都无请假功能。<br>本小程序集成扫码这一便利方式的同时采用自动获取定位来确保学生课堂到位情况真实性，增设请假功能模块，且轻便小巧。</p><h4 id="5-Delivery-推广"><a href="#5-Delivery-推广" class="headerlink" title="5.Delivery 推广"></a>5.Delivery 推广</h4><p>先于本课堂试行，在不断吸收用户反馈意见以及改进的基础上，再向学院、学校、地区、逐级推广。</p><h3 id="二、软件概述"><a href="#二、软件概述" class="headerlink" title="二、软件概述"></a>二、软件概述</h3><h4 id="1-系统功能框架"><a href="#1-系统功能框架" class="headerlink" title="1.系统功能框架"></a>1.系统功能框架</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E6%95%99%E5%B8%88%E7%AB%AF1.jpg"><br><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E7%94%9F%E7%AB%AF1.jpg"></p><h4 id="2-功能逻辑流程图"><a href="#2-功能逻辑流程图" class="headerlink" title="2.功能逻辑流程图"></a>2.功能逻辑流程图</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E6%95%99%E5%B8%88%E7%AB%AF2.jpg#pic_center"><br><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E7%94%9F%E7%AB%AF2.jpg#pic_center"></p><h3 id="三、PSP表格"><a href="#三、PSP表格" class="headerlink" title="三、PSP表格"></a>三、PSP表格</h3><table><thead><tr><th>Personal Software Process Stages</th><th>预估耗时（分钟）</th><th>实际耗时（分钟）</th></tr></thead><tbody><tr><td>Planning（计划）</td><td>60</td><td>30</td></tr><tr><td>Estimate（估计时间）</td><td>10</td><td>5</td></tr><tr><td>Development（开发）</td><td>0</td><td>0</td></tr><tr><td>Analysis（需求分析（包括学习新技术））</td><td>60</td><td>90</td></tr><tr><td>Design Spec（生成设计文档）</td><td>30</td><td>60</td></tr><tr><td>Design Review（设计复审）</td><td>0</td><td>0</td></tr><tr><td>Coding Standard（代码规范 ）</td><td>0</td><td>0</td></tr><tr><td>Design（具体设计）</td><td>400</td><td>500</td></tr><tr><td>Coding（具体编码）</td><td>0</td><td>0</td></tr><tr><td>Code Review（代码复审）</td><td>0</td><td>0</td></tr><tr><td>Test（测试（自我测试，修改代码，提交修改））</td><td>0</td><td>0</td></tr><tr><td>Test Report（测试报告）</td><td>0</td><td>0</td></tr><tr><td>Size Measurement（计算工作量）</td><td>10</td><td>15</td></tr><tr><td>Postmortem &amp; Process Improvement Plan（事后总结, 并提出过程改进计划）</td><td>30</td><td>20</td></tr><tr><td>Total（合计）</td><td>600</td><td>720</td></tr></tbody></table><h3 id="四、纸画原型以及结对照片"><a href="#四、纸画原型以及结对照片" class="headerlink" title="四、纸画原型以及结对照片"></a>四、纸画原型以及结对照片</h3><h4 id="1-原型草图"><a href="#1-原型草图" class="headerlink" title="1. 原型草图"></a>1. 原型草图</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E8%8D%89%E5%9B%BE1.jpg"><br><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E8%8D%89%E5%9B%BE2.jpg"></p><h4 id="2-结对照片"><a href="#2-结对照片" class="headerlink" title="2.结对照片"></a>2.结对照片</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E7%BB%93%E9%98%9F%E7%85%A7%E7%89%87.jpg"></p><h3 id="五、原型设计"><a href="#五、原型设计" class="headerlink" title="五、原型设计"></a>五、原型设计</h3><p><a href="https://modao.cc/app/aA3ugTpTriyahoqHlBZVTF%20#%E7%AD%BE%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%86%E4%BA%AB">[原型链接]</a></p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><ul><li>032002603：本次结队作业我基本上学会了设计一个软件原型的基本流程，以及掌握了使用墨刀进行原型设计的简单操作，在功能设计上大致上满足了我们预先的想法，但是在界面美感上可能还需要进行一定的优化。</li><li>032002604：我之前有做过产品功能需求分析并以文档形式呈现的经历，但是本次作业是我首次针对用户需求进行产品设计，这和单纯的收集并分析用户需求是种截然不同的体验。要设计出一款好的产品需要先考虑基础框架，再决定细节实现。对我来说，这是一次对计算机工作者的认知提升。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>学习笔记</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自我介绍</title>
    <link href="/2022/09/16/introducemyself/"/>
    <url>/2022/09/16/introducemyself/</url>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我是2020级计算机类6班的一名学生，大学之中没有什么亮眼的表现，在班级和年级中几乎是小透明的存在。自己学业一般，虽然一直抱着得过且过的心态，但是自己确确实实有努力学习课程（毕竟自己的智商不允许我太随便了）。<br>我觉得自己么什么感兴趣的东西，真要说的话就是平时爱听歌吧（周董YYDS  (≧▽≦ )&#x2F; )，还有就是之前大一的时候没事就喜欢睡觉。</p><p><img src="/img/introduce/Jay.jpg"></p><h2 id="自我能力评估"><a href="#自我能力评估" class="headerlink" title="自我能力评估"></a>自我能力评估</h2><p>自己代码能力不强，课外自学基本也都是心血来潮，很多时候都是东一点，西一点，到头来都是皮毛，不经常使用就忘掉了。自己基本上没参加过什么团队的开发项目，这也是我的硬伤。</p><ul><li><p>我掌握的</p><ul><li>c&#x2F;c++基础</li><li>数据结构的皮毛</li><li>web前端（目前只会一点html css）</li><li>java基础</li></ul></li><li><p>我缺少的</p><ul><li>实践经验</li><li>团队协作能力</li><li>一套完整的软件开发流程</li><li>后端开发的深入研究</li><li>课外自学能力</li></ul></li></ul><h2 id="未来期望"><a href="#未来期望" class="headerlink" title="未来期望"></a>未来期望</h2><p>自我感觉自己的学习效率不高，脑子也没有同龄的同学们这么灵光，而计算机这门学科又是如此的日新月异，想要跟上节奏还要加把劲，不断地学习。还有期待自己在实习工作能够尽量的积累经验，这方面的经验自己也是非常的缺少，先在福州工作一段时间，能够在家乡找到好的工作那当然更好。</p><p>ps:基本上是作业一里的内容</p>]]></content>
    
    
    
    <tags>
      
      <tag>自我介绍</tag>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破站上线</title>
    <link href="/2022/09/15/firstblog/"/>
    <url>/2022/09/15/firstblog/</url>
    
    <content type="html"><![CDATA[<h2 id="简单说一说"><a href="#简单说一说" class="headerlink" title="简单说一说"></a>简单说一说</h2><p>这个网站是自己瞎捣鼓了好几天，终于稍微有点雏形了的，小白搭建网站没有那么花里胡哨。希望以后继续努力吧，加油鸭！！！</p><p><img src="/img/firstblog/fighting.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>说明</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
