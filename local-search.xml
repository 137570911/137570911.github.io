<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>初始MySQL</title>
    <link href="/2022/10/15/%E5%88%9D%E8%AF%86MySQL/"/>
    <url>/2022/10/15/%E5%88%9D%E8%AF%86MySQL/</url>
    
    <content type="html"><![CDATA[<p>所有的网络应用都有基于数据的操作，数据的安全存储就靠数据库了，所以数据库在网络应用中的重要性是不言而喻的，一般在企业里进行开发都会使用到MySQL数据库，所以在之后我们将详细的学习MySQL数据库的用法。</p><p>MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。</p><p>由于MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。MySQL因为其速度、可靠性和适应性而备受关注。大多数人都认为在不需要事务化处理的情况下，MySQL是管理内容最好的选择。</p><p>MySQL这个名字，起源不是很明确。一个比较有影响的说法是，基本指南和大量的库和工具带有前缀“my”已经有10年以上，而且不管怎样，MySQL AB创始人之一的Monty Widenius的女儿也叫My。这两个到底是哪一个给出了MySQL这个名字至今依然是个迷，包括开发者在内也不知道。</p><p>MySQL的海豚标志的名字叫“sakila”，它是由MySQL AB的创始人从用户在“海豚命名”的竞赛中建议的大量的名字表中选出的。获胜的名字是由来自非洲斯威士兰的开源软件开发者Ambrose Twebaze提供。根据Ambrose所说，Sakila来自一种叫SiSwati的斯威士兰方言，也是在Ambrose的家乡乌干达附近的坦桑尼亚的Arusha的一个小镇的名字。<br>MySQL，虽然功能未必很强大，但因为它的开源、广泛传播，导致很多人都了解到这个数据库。它的历史也富有传奇性。</p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><h3 id="一、连接数据库"><a href="#一、连接数据库" class="headerlink" title="一、连接数据库"></a>一、连接数据库</h3><p>输入命令：mysql -u用户名 -p密码<br>在平台上连接数据库：mysql -u用户名 -p密码 -h127.0.0.1</p><h3 id="二、创建数据库"><a href="#二、创建数据库" class="headerlink" title="二、创建数据库"></a>二、创建数据库</h3><p>连接上MySQL后就可以进行数据库的操作了，接下来我们创建一个名为TestDb的数据库：<br><img src="https://img-blog.csdnimg.cn/img_convert/da3f5054ad4e0948e5f935614c9244d6.png"><br>创建完数据库之后我们可以通过show databases;命令查看MySQL中已存在的数据库。<br><img src="https://img-blog.csdnimg.cn/img_convert/051b0e0a47a92e0f65eaccff8972c388.png"></p><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p><strong>【注】在MySQL数据库中是不区分大小写的</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/8d352209b2ffa90e060bfccbd867081e.png"></p><h3 id="一、创建数据库"><a href="#一、创建数据库" class="headerlink" title="一、创建数据库"></a>一、创建数据库</h3><p>CREATE DATABASE MyDb;</p><h3 id="二、选择数据库"><a href="#二、选择数据库" class="headerlink" title="二、选择数据库"></a>二、选择数据库</h3><p>USE MyDb;</p><h3 id="三、创建t-user表"><a href="#三、创建t-user表" class="headerlink" title="三、创建t_user表"></a>三、创建t_user表</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_user<br>(<br>  id <span class="hljs-type">INT</span>,<br>  username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>  <span class="hljs-keyword">password</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>  phone <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">11</span>)<br>);<br></code></pre></td></tr></table></figure><h2 id="使用主键约束"><a href="#使用主键约束" class="headerlink" title="使用主键约束"></a>使用主键约束</h2><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>是表中一列或者多列的组合，主键约束（Primary Key Constraint）要求主键列的数据唯一，并且不允许为空，主键能够唯一的标识表中的每一条记录，可以结合外键来定义与不同数据表之间的关系。<br>怎么理解主键呢？我们知道数据库中的表可以存放很多数据，如果把表中的每一个数据比作一个人的话，那么<strong>表的主键</strong>就可以看做是<strong>人的身份证</strong>。</p><h4 id="添加主键约束"><a href="#添加主键约束" class="headerlink" title="添加主键约束"></a>添加主键约束</h4><p>有两种方式可以添加主键约束：<br>1.在定义列的同时指定主键；<br>2.在定义完字段之后再指定主键。</p><p>(1) 在定义列的同时指定主键：<br><img src="https://img-blog.csdnimg.cn/img_convert/46a7a19720362ba753f8bd30a95a0aaa.png"><br>(2) 在定义完所有列之后指定主键。<br><img src="https://img-blog.csdnimg.cn/img_convert/b190a25f95105153b3a0ee2c12c223ca.png"></p><h4 id="多字段联合主键"><a href="#多字段联合主键" class="headerlink" title="多字段联合主键"></a>多字段联合主键</h4><p>在开发中还有一种情况很常见，就是将几个字段联合在一起作为主键，那这个在代码中怎么实现呢？<br>举个例子，我们将员工的名字和部门ID联合起来作为主键：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_emp2<br>(<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>),<br>deptId <span class="hljs-type">INT</span>,<br>salary <span class="hljs-type">FLOAT</span>,<br><span class="hljs-keyword">PRIMARY KEY</span>(<span class="hljs-type">name</span>,deptId)<br>)<br></code></pre></td></tr></table></figure><p>语句执行后，会将name和deptId字段组合成为表t_emp2的多字段组合主键。</p><h2 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h2><h3 id="外部关键字"><a href="#外部关键字" class="headerlink" title="外部关键字"></a>外部关键字</h3><p>在以后我们统一将外部关键字叫做外键，外键就是另一张表中的主键。</p><p><strong>问</strong>：外键有啥用啊？<br><strong>答</strong>：外键的主要作用就是保持数据的一致性，完整性。</p><p><strong>再问</strong>：怎么保证的呢？<br><strong>答</strong>：看图。<br><img src="https://img-blog.csdnimg.cn/img_convert/55d3d471d89158367f4d8a098312b5c3.png"><br>如图有两张表，classId 是T_Student的外键，是T_class 表的主键， 如果我们要删除T_class 表中classId为1的字段，程序是会<strong>报错</strong>的，因为t_student表中有数据和classId为1的字段关联了，是不能删除的，这样子就保证了数据的<strong>一致性和完整性</strong>。</p><p><strong>继续问</strong>：那怎么才能删除呢？<br><strong>接着答</strong>：需要先删除T__student表中classId为1的两个字段。</p><p>如何给表添加外部关键字</p><p>在MySQL中给表中字段添加外键约束的语法规则如下：</p><p>CONSTRAINT 外键名 FOREIGN KEY 字段名 REFERENCES 主表名(主键名)<br>举个例子：现在有两张表，t_emp、t_dept如下。</p><p>t_dept表</p><table><thead><tr><th><strong>字段名称</strong></th><th><strong>数据类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>deptId</td><td>INT</td><td>部门编号</td></tr><tr><td>name</td><td>VARCHAR(22)</td><td>部门名称</td></tr><tr><td>location</td><td>VARCHAR(50)</td><td>部门位置</td></tr><tr><td>t_emp表</td><td></td><td></td></tr></tbody></table><table><thead><tr><th><strong>字段名称</strong></th><th><strong>数据类型</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>员工编号</td></tr><tr><td>name</td><td>VARCHAR(22)</td><td>员工姓名</td></tr><tr><td>deptId</td><td>INT</td><td>部门ID(外键类型必须和对应主键类型一直)</td></tr><tr><td>我们来创建两张表，并给员工表(t_emp)添加外键：</td><td></td><td></td></tr></tbody></table><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_dept<br>(<br>deptId <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>),<br><span class="hljs-keyword">location</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>);<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_emp<br>(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>),<br>deptId <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">CONSTRAINT</span> fk_emp_dept1 <span class="hljs-keyword">FOREIGN KEY</span>(deptId) <span class="hljs-keyword">REFERENCES</span> t_dept(deptId)<br>);<br></code></pre></td></tr></table></figure><p>实际操作如图：<br><img src="https://img-blog.csdnimg.cn/img_convert/faef997fedf7605b9d6905e243a3db5f.png"></p><h2 id="添加常用约束"><a href="#添加常用约束" class="headerlink" title="添加常用约束"></a>添加常用约束</h2><p>在数据库的使用过程中我们经常要限制字段的取值，比如有些字我们不能让它为空，我们就需要添加非空约束。</p><h3 id="怎么添加唯一约束"><a href="#怎么添加唯一约束" class="headerlink" title="怎么添加唯一约束"></a>怎么添加唯一约束</h3><p>唯一约束（Unique Constraint）要求该列唯一，允许为空，但是只能有一个空值。唯一约束可以确保一列或者几列不出现重复值。</p><p>定义部门表的部门名称唯一，SQL语句如下：关键词 UNIQUE。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_dept(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>) <span class="hljs-keyword">UNIQUE</span>,<br><span class="hljs-keyword">location</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="怎么添加非空约束"><a href="#怎么添加非空约束" class="headerlink" title="怎么添加非空约束"></a>怎么添加非空约束</h3><p>关键词：NOT NULL；</p><p>例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_dept(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">location</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)<br>)<br></code></pre></td></tr></table></figure><h3 id="怎么使用默认约束"><a href="#怎么使用默认约束" class="headerlink" title="怎么使用默认约束"></a>怎么使用默认约束</h3><p>默认约束：即给字段一个默认值。<br>关键词：DEFAULT；</p><p>例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_emp(<br>id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">22</span>),<br>sex <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;男&#x27;</span><br>) <span class="hljs-keyword">DEFAULT</span> CHARSET=utf8;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>如果是添加字符串型默认值要使用单引号，如果是整型则不需要加任何符号；</li><li>如果要添加的是中文默认值，则需要加上DEFAULT CHARSET&#x3D;utf8;使用英文字符则不需要。<br>设置表的属性值自动增加</li></ul><p>在数据库应用中，经常有个需求就是，在每次插入新纪录时，系统自动生成字段的主键值，即：</p><table><thead><tr><th><strong>id</strong></th><th><strong>name</strong></th></tr></thead><tbody><tr><td>1</td><td>张三</td></tr><tr><td>2</td><td>李四</td></tr><tr><td>ID每次自动加一</td><td>姓名</td></tr><tr><td>…</td><td>XXX</td></tr><tr><td>10</td><td>XXX</td></tr><tr><td>关键词：AUTO_INCREMENT，默认情况下初始值和增量都为1。</td><td></td></tr></tbody></table><p>例如：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t_tmp<br>(<br>id <span class="hljs-type">int</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT,<br><span class="hljs-type">name</span> <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>)<br>)<br></code></pre></td></tr></table></figure><p>编程要求</p><p>在数据库MyDb中创建表t_user，表结构如下：</p><table><thead><tr><th>字段名称</th><th>数据类型</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>INT</td><td>用户ID，主键，自动增长</td></tr><tr><td>username</td><td>varchar(32)</td><td>用户名，非空，唯一</td></tr><tr><td>sex</td><td>varchar(4)</td><td>性别，默认“男”</td></tr><tr><td>提示：若要给字段添加两个或者两个以上的约束，约束之间以空格隔开即可。</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程通信</title>
    <link href="/2022/10/15/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/10/15/Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<p>Linux 作为一个多任务多进程的操作系统，各个进程间信息交互<br>不可避免，进程间通信可分为本地进程间通信和远程进程间通信。本地进<br>程间通信主要包括信号，管道，消息队列，信号量，共享内存等通信方式。</p><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*使用命名管道FIFO机制实现客户到服务器之间传递数据的操作。多客户-单一服务器模式*/</span><br><span class="hljs-regexp">/*命名管道文件需创建在Linux文件系统内*/</span><br><span class="hljs-regexp">/*在一个终端窗口中运行fifo-server程序，然后在另外一个终端窗口运行fifo-client程序*/</span><br><br><span class="hljs-regexp">/*fifo-server.c */</span><br><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/stat.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;linux/stat.h&gt;</span><br><br><span class="hljs-comment">#define FIFO_FILE &quot;/tmp/MYFIFO&quot; /*命名管道的路径、文件名*/</span><br><br>int main()<br>&#123;<br>FILE *fp;<br>char readbuf[<span class="hljs-number">80</span>];<br><br><span class="hljs-keyword">if</span>((fp=fopen(FIFO_FILE,<span class="hljs-string">&quot;r&quot;</span>))==NULL)<span class="hljs-regexp">/*如果命名管道文件不存在，要先创建一个*/</span><br>&#123;<br>umask(<span class="hljs-number">0</span>);<span class="hljs-regexp">//</span>清除文件创建时权限位的屏蔽作用<br>mknod(FIFO_FILE,S_IFIFO|<span class="hljs-number">0666</span>,<span class="hljs-number">0</span>);<span class="hljs-regexp">//</span>创建FIFO文件<br>printf(<span class="hljs-string">&quot;create new fifo successed. \n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br> fclose(fp);<br><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span>((fp=fopen(FIFO_FILE,<span class="hljs-string">&quot;r&quot;</span>))==NULL)<span class="hljs-regexp">/*打开命名管道文件*/</span><br> &#123;<br>printf(<span class="hljs-string">&quot;open fifo failed. \n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span>(fgets(readbuf,<span class="hljs-number">80</span>,fp)!=NULL)<span class="hljs-regexp">/*从命名管道文件中读数据*/</span><br>&#123;<br>printf(<span class="hljs-string">&quot;Received string :%s \n&quot;</span>, readbuf);<br>fclose(fp);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(ferror(fp))<br>&#123;<br>printf(<span class="hljs-string">&quot;read fifo failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*使用命名管道FIFO机制实现客户到服务器之间传递数据的操作。多客户-单一服务器模式*/</span><br><span class="hljs-regexp">/*命名管道文件需创建在Linux文件系统内*/</span><br><span class="hljs-regexp">/*在一个终端窗口中运行fifo-server程序，然后在另外一个终端窗口运行fifo-client程序*/</span><br><br><span class="hljs-regexp">/*fifo-client.c */</span><br><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><br><span class="hljs-comment">#define FIFO_FILE &quot;/tmp/MYFIFO&quot;/*命名管道的路径、文件名*/</span><br><br>int main(int argc, char *argv[])<br>&#123;<br>FILE *fp;<br>int i;<br><span class="hljs-keyword">if</span>(argc&lt;=<span class="hljs-number">1</span>)<br>&#123;<br>printf(<span class="hljs-string">&quot;usage: %s &lt;message&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br> <br><span class="hljs-keyword">if</span>((fp=fopen(FIFO_FILE,<span class="hljs-string">&quot;w&quot;</span>))==NULL)<span class="hljs-regexp">/*打开命名管道文件*/</span><br>&#123;<br>printf(<span class="hljs-string">&quot;open fifo failed. \n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;argc;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(fputs(argv[i],fp)==EOF)<br>&#123;<br>printf(<span class="hljs-string">&quot;write fifo error. \n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(fputs(<span class="hljs-string">&quot; &quot;</span>,fp)==EOF)<br>&#123;<br>printf(<span class="hljs-string">&quot;write fifo error. \n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>fclose(fp);<br>return <span class="hljs-number">0</span>;<br> <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>发送端</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*使用消息队列机制实现发送接收消息的操作。*/</span><br><span class="hljs-comment">/*在一个终端窗口中运行msg-send程序，然后在另外一个终端窗口运行msg-recieve程序*/</span><br><br><span class="hljs-comment">/*msg-send.c */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_msg</span><span class="hljs-comment">//消息的组成</span><br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> my_msg_type;<span class="hljs-comment">//消息的类型域</span><br><span class="hljs-type">char</span> text[BUFSIZ];<span class="hljs-comment">//消息传递的数据域</span><br>&#125; msgbuf;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> running =<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> msgid;<br>msgid=<span class="hljs-built_in">msgget</span>((<span class="hljs-type">key_t</span>)<span class="hljs-number">1234</span>,<span class="hljs-number">0666</span> |IPC_CREAT);<span class="hljs-comment">//打开key值为1234的消息队列，如不存在则创建之</span><br><span class="hljs-keyword">if</span>(msgid==<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgget failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">while</span>(running)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter some text: &quot;</span>);<br><span class="hljs-built_in">fgets</span>(msgbuf.text,BUFSIZ,stdin);<span class="hljs-comment">//读入键盘输入的消息</span><br>msgbuf.my_msg_type=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">msgsnd</span>(msgid,(<span class="hljs-type">void</span> *)&amp;msgbuf, BUFSIZ, <span class="hljs-number">0</span>)==<span class="hljs-number">-1</span>)<span class="hljs-comment">//发送消息</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgsnd failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(msgbuf.text,<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-number">3</span>)==<span class="hljs-number">0</span>)<span class="hljs-comment">//输入end表示程序结束</span><br>running=<span class="hljs-number">0</span>;<br>&#125;<br>       <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接收端</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*使用消息队列机制实现发送接收消息的操作。*/</span><br><span class="hljs-comment">/*在一个终端窗口中运行msg-send程序，然后在另外一个终端窗口运行msg-recieve程序*/</span><br><br><span class="hljs-comment">/*msg-recieve.c */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">my_msg</span><span class="hljs-comment">//消息的组成</span><br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> my_msg_type;<span class="hljs-comment">//消息的类型域</span><br><span class="hljs-type">char</span> text[BUFSIZ];<span class="hljs-comment">//消息传递的数据域</span><br>&#125; msgbuf;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> running =<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> msgid;<br><span class="hljs-type">long</span> <span class="hljs-type">int</span> msg_to_receive=<span class="hljs-number">0</span>;<br>msgid=<span class="hljs-built_in">msgget</span>((<span class="hljs-type">key_t</span>)<span class="hljs-number">1234</span>,<span class="hljs-number">0666</span> |IPC_CREAT);<span class="hljs-comment">//打开key值为1234的消息队列，如不存在则创建之</span><br><span class="hljs-keyword">if</span>(msgid==<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgget failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">while</span>(running)<br>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">msgrcv</span>(msgid,(<span class="hljs-type">void</span> *)&amp;msgbuf, BUFSIZ,msg_to_receive, <span class="hljs-number">0</span>)==<span class="hljs-number">-1</span>)<span class="hljs-comment">//接收消息</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgrcv failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;You wrote : %s&quot;</span>, msgbuf.text);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">strncmp</span>(msgbuf.text,<span class="hljs-string">&quot;end&quot;</span>,<span class="hljs-number">3</span>)==<span class="hljs-number">0</span>)<span class="hljs-comment">//收到end表示程序结束</span><br>running=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">msgctl</span>(msgid, IPC_RMID, <span class="hljs-number">0</span>)==<span class="hljs-number">-1</span>)<span class="hljs-comment">//删除消息队列</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;msgct(IPC_RMID)  failed!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>写入端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*使用共享内存机制实现通信*/</span><br><span class="hljs-regexp">/*在一个终端窗口中先运行shm-write程序，然后在另外一个终端窗口运行shm-read程序*/</span><br><br><span class="hljs-regexp">/*shm-write.c */</span><br><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/ipc.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/shm.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;string.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><br>int main()<br>&#123;<br>int shmid;<br>char c;<br>char *shmptr, *s;<br><span class="hljs-keyword">if</span>((shmid=shmget(<span class="hljs-number">1234</span>,<span class="hljs-number">256</span>,IPC_CREAT | <span class="hljs-number">0666</span>))&lt;<span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>打开key值为<span class="hljs-number">1234</span>的共享内存，如不存在则创建之<br>&#123;<br>printf(<span class="hljs-string">&quot;shmget failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>((shmptr=shmat(shmid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))==(char*)-<span class="hljs-number">1</span>)<span class="hljs-regexp">//</span>附加此共享内存至自己的地址空间，返回内存区域的指针<br>&#123;<br>shmctl(shmid, IPC_RMID, (struct shmid_ds*)shmptr);<br>printf(<span class="hljs-string">&quot;shmat failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">2</span>);<br>&#125;<br>s=shmptr;<span class="hljs-regexp">//</span> 写共享内存通过指针s操作<br><span class="hljs-keyword">for</span>(c=<span class="hljs-string">&#x27;a&#x27;</span>;c&lt;=<span class="hljs-string">&#x27;z&#x27;</span>;c++)<span class="hljs-regexp">//</span>写入<span class="hljs-number">26</span>个字母<br>*s++=c;<br>s=<span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-keyword">while</span>(*shmptr!=<span class="hljs-string">&#x27;*&#x27;</span>)<span class="hljs-regexp">//</span>等待直到读进程已写入“*”表示读完数据<br>sleep(<span class="hljs-number">1</span>);<br>shmctl(shmid, IPC_RMID, (struct shmid_ds*)shmptr);<span class="hljs-regexp">//</span>删除共享内存<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*使用共享内存机制实现通信*/</span><br><span class="hljs-regexp">/*在一个终端窗口中先运行shm-write程序，然后在另外一个终端窗口运行shm-read程序*/</span><br><br><span class="hljs-regexp">/*shm-read.c */</span><br><br><span class="hljs-comment">#include &lt;sys/types.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/ipc.h&gt;</span><br><span class="hljs-comment">#include &lt;sys/shm.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br><span class="hljs-comment">#include &lt;string.h&gt;</span><br><br>int main()<br>&#123;<br><br>int shmid;<br>char c;<br>char*shmptr, *s;<br><span class="hljs-keyword">if</span>((shmid=shmget(<span class="hljs-number">1234</span>,<span class="hljs-number">256</span>, <span class="hljs-number">0666</span>))&lt;<span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>打开key值为<span class="hljs-number">1234</span>的共享内存<br>&#123;<br>printf(<span class="hljs-string">&quot;shmget failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span>((shmptr=shmat(shmid,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))==(char*)-<span class="hljs-number">1</span>)<span class="hljs-regexp">//</span>附加此共享内存至自己的地址空间<br>&#123;<br>shmctl(shmid,IPC_RMID,(struct shmid_ds*)shmptr);<br>printf(<span class="hljs-string">&quot;shmat failed.\n&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">for</span>(s=shmptr;*s!=<span class="hljs-string">&#x27;\0&#x27;</span>;s++)<span class="hljs-regexp">//</span>读出<span class="hljs-number">26</span>个字母<br>putchar(*s);<br>printf(<span class="hljs-string">&quot;\n&quot;</span>);<br>*shmptr=<span class="hljs-string">&#x27;*&#x27;</span>;<span class="hljs-regexp">//</span>写入“*”到共享内存表示读完数据<br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>头文件</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">/*共享内存机制可以直接读取内存，所以其通信效率高于管道和消息队列*/</span><br><span class="hljs-comment">/*由于多个进程对同一块内存区域具有访问的权限，进程之间的同步就非常重要*/</span><br><span class="hljs-comment">/*使用信号量机制PV操作来同步的共享内存机制通信*/</span><br><span class="hljs-comment">/*在一个终端窗口中先运行semshm-write程序，然后在另外一个终端窗口运行semshm-read程序*/</span><br><br><span class="hljs-comment">/*semshm-.h */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;error.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHM_SIZE     1024</span><br><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">semun</span>&#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">semid_ds</span> *buf;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *array;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">seminfo</span> *buf_info;<br>    <span class="hljs-type">void</span> *pad;<br>&#125;;<br><br><span class="hljs-comment">/* 创建信号量函数*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creatsem</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id, <span class="hljs-type">int</span> members, <span class="hljs-type">int</span> init_val)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">key_t</span> msgkey;<br>    <span class="hljs-type">int</span> index, sid;<br>    <span class="hljs-keyword">union</span> <span class="hljs-title class_">semun</span> semopts;<br>    <br>    <span class="hljs-keyword">if</span>((msgkey = <span class="hljs-built_in">ftok</span>(pathname, proj_id)) == <span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//利用ftok函数生成键值，自行指定的键值可能会冲突</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ftok error!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((sid = <span class="hljs-built_in">semget</span>(msgkey, members, IPC_CREAT|<span class="hljs-number">0666</span>)) == <span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//打开键值为msgkey的信号量集，如不存在则创建之，返回信号量集标识符。members为信号量集中含信号量的数目。</span><br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;semget call failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    semopts.val = init_val;<br>    <span class="hljs-keyword">for</span>(index = <span class="hljs-number">0</span>; index &lt; members; index++)&#123;<br>        <span class="hljs-built_in">semctl</span>(sid, index, SETVAL, semopts);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> sid;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">opensem</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">key_t</span> msgkey;<br>    <span class="hljs-type">int</span> sid;<br>    <br>    <span class="hljs-keyword">if</span>((msgkey = <span class="hljs-built_in">ftok</span>(pathname, proj_id)) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ftok error!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span>((sid = <span class="hljs-built_in">semget</span>(msgkey, <span class="hljs-number">0</span>, <span class="hljs-number">0666</span>)) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;open semget call failed.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sid;<br>&#125;<br><br><span class="hljs-comment">/* p操作, 获取信号量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_p</span><span class="hljs-params">(<span class="hljs-type">int</span> semid, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> sbuf = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, IPC_NOWAIT&#125;;<span class="hljs-comment">//每个sembuf结构描述了一个对信号量的操作</span><br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;index of array cannot equals a minus value!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sbuf.sem_num = index;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">semop</span>(semid, &amp;sbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;A wrong operation to semaphore occurred!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* V操作, 释放信号量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_v</span><span class="hljs-params">(<span class="hljs-type">int</span> semid, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sembuf</span> sbuf = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, IPC_NOWAIT&#125;;<span class="hljs-comment">//每个sembuf结构描述了一个对信号量的操作</span><br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;index of array cannot equals a minus value!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    sbuf.sem_num = index;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">semop</span>(semid, &amp;sbuf, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;A wrong operation to semaphore occurred!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 删除信号量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sem_delete</span><span class="hljs-params">(<span class="hljs-type">int</span> semid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">semctl</span>(semid, <span class="hljs-number">0</span>, IPC_RMID));<br>&#125;<br><br><span class="hljs-comment">/* 等待信号量*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">wait_sem</span><span class="hljs-params">(<span class="hljs-type">int</span> semid, <span class="hljs-type">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">semctl</span>(semid, index, GETVAL, <span class="hljs-number">0</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">usleep</span>(<span class="hljs-number">500</span>);<br>    &#125; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>&#125;<br><br><span class="hljs-comment">/* 创建共享内存*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creatshm</span><span class="hljs-params">(<span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> proj_id, <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">key_t</span> shmkey;<br>    <span class="hljs-type">int</span> sid;<br>    <br>    <span class="hljs-keyword">if</span>((shmkey = <span class="hljs-built_in">ftok</span>(pathname, proj_id)) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;ftok error!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>((sid = <span class="hljs-built_in">shmget</span>(shmkey, size, IPC_CREAT|<span class="hljs-number">0666</span>)) == <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;shm call failed!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sid;<br>&#125;<br><br><span class="hljs-comment">/* 删除共享内存*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteshm</span><span class="hljs-params">(<span class="hljs-type">int</span> sid)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">void</span> *p = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">shmctl</span>(sid, IPC_RMID, p));<br>&#125;<br></code></pre></td></tr></table></figure><p>写入端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*共享内存机制可以直接读取内存，所以其通信效率高于管道和消息队列*/</span><br><span class="hljs-regexp">/*由于多个进程对同一块内存区域具有访问的权限，进程之间的同步就非常重要*/</span><br><span class="hljs-regexp">/*使用信号量机制PV操作来同步的共享内存机制通信*/</span><br><span class="hljs-regexp">/*在一个终端窗口中先运行semshm-write程序，然后在另外一个终端窗口运行semshm-read程序*/</span><br><br><span class="hljs-regexp">/*semshm-write.c */</span><br><br><span class="hljs-comment">#include &quot;2-4semshm-.h&quot;</span><br><br>int main(int argc, char** argv)<br>&#123;<br>    int semid, shmid;<br>    char *shmaddr;<br>    char write_str[SHM_SIZE];<br>    char *ret;<br>    <span class="hljs-keyword">if</span>((shmid = creatshm(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">57</span>, SHM_SIZE)) == -<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span>创建或者获取共享内存<br>        return -<span class="hljs-number">1</span>;<br><span class="hljs-regexp">/*建立进程和共享内存连接*/</span><br>    <span class="hljs-keyword">if</span>((shmaddr = shmat(shmid, (char*)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) == (char *)-<span class="hljs-number">1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;attch shared memory error!\n&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;    <br>    <span class="hljs-keyword">if</span>((semid = creatsem(<span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-number">39</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)) == -<span class="hljs-number">1</span>)<span class="hljs-regexp">//</span>创建信号量<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        wait_sem(semid, <span class="hljs-number">0</span>);<span class="hljs-regexp">//</span>等待信号量可以被获取<br>        sem_p(semid, <span class="hljs-number">0</span>);  <span class="hljs-regexp">//</span>获取信号量<br><span class="hljs-regexp">/***************写共享内存***************************************************/</span><br>        printf(<span class="hljs-string">&quot;write : &quot;</span>);<br>        ret = fgets(write_str, <span class="hljs-number">1024</span>, stdin);<br>        <span class="hljs-keyword">if</span>(write_str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;#&#x27;</span>结束读写进程<br>            <span class="hljs-keyword">break</span>;<br>        int len = strlen(write_str);<br>        write_str[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        strcpy(shmaddr, write_str);<br><span class="hljs-regexp">/****************************************************************************/</span><br>        sem_v(semid, <span class="hljs-number">0</span>); <span class="hljs-regexp">//</span>释放信号量<br>        usleep(<span class="hljs-number">1000</span>);  <span class="hljs-regexp">//</span>本进程睡眠.<br>    &#125;<br>    sem_delete(semid); <span class="hljs-regexp">//</span>把semid指定的信号集从系统中删除<br>    deleteshm(shmid);   <span class="hljs-regexp">//</span>从系统中删除shmid标识的共享内存<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取端</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*共享内存机制可以直接读取内存，所以其通信效率高于管道和消息队列*/</span><br><span class="hljs-regexp">/*由于多个进程对同一块内存区域具有访问的权限，进程之间的同步就非常重要*/</span><br><span class="hljs-regexp">/*使用信号量机制PV操作来同步的共享内存机制通信*/</span><br><span class="hljs-regexp">/*在一个终端窗口中先运行semshm-write程序，然后在另外一个终端窗口运行semshm-read程序*/</span><br><br><span class="hljs-regexp">/*semshm-read.c */</span><br><br><span class="hljs-comment">#include &quot;2-4semshm-.h&quot;</span><br><br>int main(int argc, char** argv)<br>&#123;<br>    int semid, shmid;<br>    char *shmaddr;<br>    <span class="hljs-keyword">if</span>((shmid = creatshm(<span class="hljs-string">&quot;.&quot;</span>, <span class="hljs-number">57</span>, SHM_SIZE)) == -<span class="hljs-number">1</span>)<br>        return -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>((shmaddr = shmat(shmid, (char*)<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) == (char *)-<span class="hljs-number">1</span>)&#123;<br>        perror(<span class="hljs-string">&quot;attch shared memory error!\n&quot;</span>);<br>        <span class="hljs-keyword">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>((semid = opensem(<span class="hljs-string">&quot;./&quot;</span>, <span class="hljs-number">39</span>)) == -<span class="hljs-number">1</span>)<br>        return -<span class="hljs-number">1</span>;<br>    printf(<span class="hljs-string">&quot;read start....................\n&quot;</span>);        <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        printf(<span class="hljs-string">&quot;read : &quot;</span>);<br>        wait_sem(semid, <span class="hljs-number">0</span>);  <span class="hljs-regexp">//</span>等待信号量可以获取<br>        <span class="hljs-keyword">if</span>(sem_p(semid, <span class="hljs-number">0</span>) == -<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span>获取信号量失败退出。当server写入<span class="hljs-string">&#x27;#&#x27;</span>时引发<br>            <span class="hljs-keyword">break</span>;<br>        printf(<span class="hljs-string">&quot;%s&quot;</span>, shmaddr);<br><br>        sem_v(semid, <span class="hljs-number">0</span>);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;    <br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux进程管理</title>
    <link href="/2022/10/08/LInux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2022/10/08/LInux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、fork函数"><a href="#一、fork函数" class="headerlink" title="一、fork函数"></a>一、fork函数</h3><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>当程序执行到fork函数时会复制一份原来的进程（创建一个新的进程），旧进程（父进程）和新进程（子进程）会继续执行fork之后的代码,父子进程执行的顺序未知。</p><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*简单了解fork函数的功能*/</span><br><span class="hljs-comment">/*父进程与子进程的执行顺序未知*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> flag;<span class="hljs-comment">//flag用于区别创建的子进程</span><br>flag = fork();<span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//子进程child_1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is child_1 process %d\n&quot;</span>,flag);<br>flag++;<br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) <span class="hljs-comment">//在子进程下创建新的子进程child_2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is child process of child_1\n&quot;</span>);<br><span class="hljs-comment">//进程 child_1</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is child_1 process %d\n&quot;</span>,flag);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//父进程</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is parent process\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/fork%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="二、exec函数族"><a href="#二、exec函数族" class="headerlink" title="二、exec函数族"></a>二、exec函数族</h3><h4 id="功能说明-1"><a href="#功能说明-1" class="headerlink" title="功能说明"></a>功能说明</h4><p>fork()函数通过系统调用创建一个与原来进程（父进程）几乎完全相同的进程（子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程不共享这些存储空间。linux将复制父进程的地址空间内容给子进程，因此，子进程由了独立的地址空间。），也就是这两个进程做完全相同的事。</p><p>正因为fork函数创建的子进程几乎等同于父进程的副本，所以我们更希望子进程可以执行不一样的操作，可以装入和运行其它程序（子进程替换原有进程，和父进程做不同的事）,使用exec函数就可以执行和父进程不一样的操作。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><table>    <tr>        <td>头文件</td>        <td>#include &#60unistd&#62</td>      </tr>    <tr>        <td>函数说明</td>        <td>执行文件</td>    </tr>    <tr>        <td rowspan="6">函数原型</td>        <td>int execl(const char *pathname, const char *arg, ...)</td>    </tr>    <tr>        <td>int execv(const char *pathname, char *const argv[])</td>    </tr>    <tr>        <td>int execle(const char *pathname, const char *arg, ..., char *const envp[])</td>    </tr>    <tr>        <td>int execve(const char *pathname, char *const argv[], char *const envp[])</td>    </tr>    <tr><td>int execvp(const char *filename, char *const argv[])</td>    </tr>    <tr>        <td>int execlp(const char *filename, const char *arg, ...)</td>    </tr>    <tr>        <td rowspan="2">函数返回值</td>        <td>成功：函数不会返回</td>    </tr>    <tr>        <td>出错：返回-1，失败原因记录在error中</td>    </tr></table><h4 id="命名语法"><a href="#命名语法" class="headerlink" title="命名语法"></a>命名语法</h4><table>    <tr>        <td>前4位</td>        <td colspan="2">统一为：exec</td>    </tr>    <tr>        <td rowspan="2">第5位</td>        <td>l：参数传递为逐个列举方式</td>        <td>execl、execle、execlp</td>    </tr>    <tr>        <td>v：参数传递为构造指针数组方式</td>        <td>execv、execve、execvp</td>    </tr>    <tr>        <td rowspan="2">第6位</td>        <td>e：可传递新进程环境变量</td>        <td>execle、execve</td>    </tr>    <tr>        <td>p：可执行文件查找方式为文件名</td>        <td>execlp、execvp</td>    </tr></table><h5 id="简单例子-1"><a href="#简单例子-1" class="headerlink" title="简单例子"></a>简单例子</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/*程序执行execlp函数和execv函数*/</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br>int main()<br>&#123;<br>pid_t pid;<br><br><span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>创建子进程child_1<br>&#123;<br><span class="hljs-regexp">//</span>错误处理<br>perror(<span class="hljs-string">&quot;fork&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-regexp">//</span>子进程child_1<br>printf(<span class="hljs-string">&quot;\nThis is child_1 process\n&quot;</span>);<br><span class="hljs-keyword">if</span>(execlp(<span class="hljs-string">&quot;pwd&quot;</span>,<span class="hljs-string">&quot;pwd&quot;</span>,NULL) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>转入执行pwd命令<br>&#123;<br>perror(<span class="hljs-string">&quot;execlp&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>printf(<span class="hljs-string">&quot;never be displayed&quot;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span>创建以NULL结尾的字符串数组指针以便execv函数使用<br>char *arg[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>,NULL&#125;;<br><span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>创建子进程child_2<br>&#123;<br>perror(<span class="hljs-string">&quot;fork&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-regexp">//</span>子进程child_2<br>printf(<span class="hljs-string">&quot;\nThis is child_2 process\n&quot;</span>);<br><span class="hljs-keyword">if</span>(execv(<span class="hljs-string">&quot;/bin/ls&quot;</span>,arg) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>转入执行ls命令<br>&#123;<br>perror(<span class="hljs-string">&quot;execv&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>printf(<span class="hljs-string">&quot;never be displayed&quot;</span>);<br>&#125;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/exec%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="三、singal函数"><a href="#三、singal函数" class="headerlink" title="三、singal函数"></a>三、singal函数</h3><h4 id="功能说明-2"><a href="#功能说明-2" class="headerlink" title="功能说明"></a>功能说明</h4><p>通过signal函数可以设置系统对于某一信号的对应的操作<br>所在函数库：#include &lt;signal.h&gt;<br>使用原型：signal(int signum,sighandler_t handler)<br>参数说明：<br>signum：信号编号<br>handler的取值：<br>忽略该信号：SIG_IGN<br>执行系统默认动作：SIG_DFL<br>自定义信号处理函数：信号处理函数名</p><h4 id="简单例子-2"><a href="#简单例子-2" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-comment">//注册printsignum函数以便使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printsignum</span><span class="hljs-params">(<span class="hljs-type">int</span> SignNum)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The signal number is %d\n&quot;</span>,SignNum);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a process\n&quot;</span>);<br><span class="hljs-built_in">signal</span>(SIGINT,printsignum);<span class="hljs-comment">//注册SIGINT信号,键接收到该信号后会执行printsignum函数</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//键入ctrl+c 执行pirntsignum函数</span><br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Never be displayed\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/signal%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="四、make函数的使用"><a href="#四、make函数的使用" class="headerlink" title="四、make函数的使用"></a>四、make函数的使用</h3><h4 id="功能说明-3"><a href="#功能说明-3" class="headerlink" title="功能说明"></a>功能说明</h4><p>使用make命令，系统会在当前目录下寻找Makefile的文件，并对它进行解释，处理，并执行相关动作。</p><h4 id="简单例子-3"><a href="#简单例子-3" class="headerlink" title="简单例子"></a>简单例子</h4><p>主程序main通过调用函数function_A执行相关操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//主函数中调用函数function_A</span><br><span class="hljs-built_in">function_A</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数function_A在同一目录下的另一c文件function_A.c中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_A</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//输出相关文字</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is function_A\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在同一目录下的makefile文件内容如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">all:</span> main.<span class="hljs-keyword">c</span> function_A.<span class="hljs-keyword">c</span><br>gcc -o all main.<span class="hljs-keyword">c</span> function_A.<span class="hljs-keyword">c</span> #次行以tab开头<br></code></pre></td></tr></table></figure><p>在此目录下键入make命令，发现目录下生成了名为all的可执行文件，执行这个文件，观察到所需的操作已经执行，结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/make%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识原型设计</title>
    <link href="/2022/10/02/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/10/02/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="事先说明"><a href="#事先说明" class="headerlink" title="事先说明"></a>事先说明</h3><p>其实主要是设计方面，个人艺术细胞不太好，没有美观的界面，只是设计了一个模型出来，无法实现其功能，这次是两人结队完成的哦</p><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><h4 id="1-Need-需求"><a href="#1-Need-需求" class="headerlink" title="1.Need 需求"></a>1.Need 需求</h4><ul><li>班级名单导入或生成，要方便易用</li><li>班级点名方式要方便易用</li><li>班级点名方式要尽可能防作弊</li><li>要支持多班级功能</li><li>要支持期末汇总统计导出</li><li>要支持请假功能</li><li>要符合小程序的规范的界面或功能要求</li></ul><h4 id="2-Approach-做法"><a href="#2-Approach-做法" class="headerlink" title="2.Approach 做法"></a>2.Approach 做法</h4><p>（1）使用原型设计工具墨刀设计基于微信小程序的课堂签到小程序；<br>（2）学生端实现学生的课堂签到、签到记录查询；<br>（3）教师端支持发布签到、管理班级、导出名单等功能。</p><h4 id="3-Benefit-好处"><a href="#3-Benefit-好处" class="headerlink" title="3.Benefit 好处"></a>3.Benefit 好处</h4><p>（1）采用分模块、分层次实现，UI简洁明了，方便用户使用；<br>（2）不同的身份定位提供不同的服务；<br>（3）采用扫码加定位签到方式，在一定程度上防止作弊.</p><h4 id="4-Competitors-竞争"><a href="#4-Competitors-竞争" class="headerlink" title="4.Competitors 竞争"></a>4.Competitors 竞争</h4><p>经调研，在本校内师生大多数使用“e点课堂”以及“雨课堂”两款小程序。其中e点并不支持教师导入导出班级成员名单，且仅采用扫码方式进行签到，缺乏有效防作弊手段；雨课堂虽然提供了共享课件以及课堂互动特色功能，但在签到功能需求上采用扫码或课堂码方式签到，也是缺乏有效防作弊手段，且两者都无请假功能。<br>本小程序集成扫码这一便利方式的同时采用自动获取定位来确保学生课堂到位情况真实性，增设请假功能模块，且轻便小巧。</p><h4 id="5-Delivery-推广"><a href="#5-Delivery-推广" class="headerlink" title="5.Delivery 推广"></a>5.Delivery 推广</h4><p>先于本课堂试行，在不断吸收用户反馈意见以及改进的基础上，再向学院、学校、地区、逐级推广。</p><h3 id="二、软件概述"><a href="#二、软件概述" class="headerlink" title="二、软件概述"></a>二、软件概述</h3><h4 id="1-系统功能框架"><a href="#1-系统功能框架" class="headerlink" title="1.系统功能框架"></a>1.系统功能框架</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E6%95%99%E5%B8%88%E7%AB%AF1.jpg"><br><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E7%94%9F%E7%AB%AF1.jpg"></p><h4 id="2-功能逻辑流程图"><a href="#2-功能逻辑流程图" class="headerlink" title="2.功能逻辑流程图"></a>2.功能逻辑流程图</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E6%95%99%E5%B8%88%E7%AB%AF2.jpg#pic_center"><br><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E7%94%9F%E7%AB%AF2.jpg#pic_center"></p><h3 id="三、PSP表格"><a href="#三、PSP表格" class="headerlink" title="三、PSP表格"></a>三、PSP表格</h3><table><thead><tr><th>Personal Software Process Stages</th><th>预估耗时（分钟）</th><th>实际耗时（分钟）</th></tr></thead><tbody><tr><td>Planning（计划）</td><td>60</td><td>30</td></tr><tr><td>Estimate（估计时间）</td><td>10</td><td>5</td></tr><tr><td>Development（开发）</td><td>0</td><td>0</td></tr><tr><td>Analysis（需求分析（包括学习新技术））</td><td>60</td><td>90</td></tr><tr><td>Design Spec（生成设计文档）</td><td>30</td><td>60</td></tr><tr><td>Design Review（设计复审）</td><td>0</td><td>0</td></tr><tr><td>Coding Standard（代码规范 ）</td><td>0</td><td>0</td></tr><tr><td>Design（具体设计）</td><td>400</td><td>500</td></tr><tr><td>Coding（具体编码）</td><td>0</td><td>0</td></tr><tr><td>Code Review（代码复审）</td><td>0</td><td>0</td></tr><tr><td>Test（测试（自我测试，修改代码，提交修改））</td><td>0</td><td>0</td></tr><tr><td>Test Report（测试报告）</td><td>0</td><td>0</td></tr><tr><td>Size Measurement（计算工作量）</td><td>10</td><td>15</td></tr><tr><td>Postmortem &amp; Process Improvement Plan（事后总结, 并提出过程改进计划）</td><td>30</td><td>20</td></tr><tr><td>Total（合计）</td><td>600</td><td>720</td></tr></tbody></table><h3 id="四、纸画原型以及结对照片"><a href="#四、纸画原型以及结对照片" class="headerlink" title="四、纸画原型以及结对照片"></a>四、纸画原型以及结对照片</h3><h4 id="1-原型草图"><a href="#1-原型草图" class="headerlink" title="1. 原型草图"></a>1. 原型草图</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E8%8D%89%E5%9B%BE1.jpg"><br><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E8%8D%89%E5%9B%BE2.jpg"></p><h4 id="2-结对照片"><a href="#2-结对照片" class="headerlink" title="2.结对照片"></a>2.结对照片</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E7%BB%93%E9%98%9F%E7%85%A7%E7%89%87.jpg"></p><h3 id="五、原型设计"><a href="#五、原型设计" class="headerlink" title="五、原型设计"></a>五、原型设计</h3><p><a href="https://modao.cc/app/aA3ugTpTriyahoqHlBZVTF%20#%E7%AD%BE%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%86%E4%BA%AB">[原型链接]</a></p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><ul><li>032002603：本次结队作业我基本上学会了设计一个软件原型的基本流程，以及掌握了使用墨刀进行原型设计的简单操作，在功能设计上大致上满足了我们预先的想法，但是在界面美感上可能还需要进行一定的优化。</li><li>032002604：我之前有做过产品功能需求分析并以文档形式呈现的经历，但是本次作业是我首次针对用户需求进行产品设计，这和单纯的收集并分析用户需求是种截然不同的体验。要设计出一款好的产品需要先考虑基础框架，再决定细节实现。对我来说，这是一次对计算机工作者的认知提升。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>作业</tag>
      
      <tag>学习笔记</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自我介绍</title>
    <link href="/2022/09/16/introducemyself/"/>
    <url>/2022/09/16/introducemyself/</url>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我是2020级计算机类6班的一名学生，大学之中没有什么亮眼的表现，在班级和年级中几乎是小透明的存在。自己学业一般，虽然一直抱着得过且过的心态，但是自己确确实实有努力学习课程（毕竟自己的智商不允许我太随便了）。<br>我觉得自己么什么感兴趣的东西，真要说的话就是平时爱听歌吧（周董YYDS  (≧▽≦ )&#x2F; )，还有就是之前大一的时候没事就喜欢睡觉。</p><p><img src="/img/introduce/Jay.jpg"></p><h2 id="自我能力评估"><a href="#自我能力评估" class="headerlink" title="自我能力评估"></a>自我能力评估</h2><p>自己代码能力不强，课外自学基本也都是心血来潮，很多时候都是东一点，西一点，到头来都是皮毛，不经常使用就忘掉了。自己基本上没参加过什么团队的开发项目，这也是我的硬伤。</p><ul><li><p>我掌握的</p><ul><li>c&#x2F;c++基础</li><li>数据结构的皮毛</li><li>web前端（目前只会一点html css）</li><li>java基础</li></ul></li><li><p>我缺少的</p><ul><li>实践经验</li><li>团队协作能力</li><li>一套完整的软件开发流程</li><li>后端开发的深入研究</li><li>课外自学能力</li></ul></li></ul><h2 id="未来期望"><a href="#未来期望" class="headerlink" title="未来期望"></a>未来期望</h2><p>自我感觉自己的学习效率不高，脑子也没有同龄的同学们这么灵光，而计算机这门学科又是如此的日新月异，想要跟上节奏还要加把劲，不断地学习。还有期待自己在实习工作能够尽量的积累经验，这方面的经验自己也是非常的缺少，先在福州工作一段时间，能够在家乡找到好的工作那当然更好。</p><p>ps:基本上是作业一里的内容</p>]]></content>
    
    
    
    <tags>
      
      <tag>自我介绍</tag>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破站上线</title>
    <link href="/2022/09/15/firstblog/"/>
    <url>/2022/09/15/firstblog/</url>
    
    <content type="html"><![CDATA[<h2 id="简单说一说"><a href="#简单说一说" class="headerlink" title="简单说一说"></a>简单说一说</h2><p>这个网站是自己瞎捣鼓了好几天，终于稍微有点雏形了的，小白搭建网站没有那么花里胡哨。希望以后继续努力吧，加油鸭！！！</p><p><img src="/img/firstblog/fighting.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>说明</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
