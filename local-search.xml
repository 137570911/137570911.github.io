<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux进程管理</title>
    <link href="/2022/10/08/LInux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2022/10/08/LInux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、fork函数"><a href="#一、fork函数" class="headerlink" title="一、fork函数"></a>一、fork函数</h3><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>一个进程，包括代码、数据和分配给进程的资源。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>当程序执行到fork函数时会复制一份原来的进程（创建一个新的进程），旧进程（父进程）和新进程（子进程）会继续执行fork之后的代码,父子进程执行的顺序未知。</p><h4 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*简单了解fork函数的功能*/</span><br><span class="hljs-comment">/*父进程与子进程的执行顺序未知*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> flag;<span class="hljs-comment">//flag用于区别创建的子进程</span><br>flag = fork();<span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span> (flag == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//子进程child_1</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is child_1 process %d\n&quot;</span>,flag);<br>flag++;<br><span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) <span class="hljs-comment">//在子进程下创建新的子进程child_2</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is child process of child_1\n&quot;</span>);<br><span class="hljs-comment">//进程 child_1</span><br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is child_1 process %d\n&quot;</span>,flag);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//父进程</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is parent process\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/fork%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="二、exec函数族"><a href="#二、exec函数族" class="headerlink" title="二、exec函数族"></a>二、exec函数族</h3><h4 id="功能说明-1"><a href="#功能说明-1" class="headerlink" title="功能说明"></a>功能说明</h4><p>fork()函数通过系统调用创建一个与原来进程（父进程）几乎完全相同的进程（子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程不共享这些存储空间。linux将复制父进程的地址空间内容给子进程，因此，子进程由了独立的地址空间。），也就是这两个进程做完全相同的事。</p><p>正因为fork函数创建的子进程几乎等同于父进程的副本，所以我们更希望子进程可以执行不一样的操作，可以装入和运行其它程序（子进程替换原有进程，和父进程做不同的事）,使用exec函数就可以执行和父进程不一样的操作。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><table>    <tr>        <td>头文件</td>        <td>#include &#60unistd&#62</td>      </tr>    <tr>        <td>函数说明</td>        <td>执行文件</td>    </tr>    <tr>        <td rowspan="6">函数原型</td>        <td>int execl(const char *pathname, const char *arg, ...)</td>    </tr>    <tr>        <td>int execv(const char *pathname, char *const argv[])</td>    </tr>    <tr>        <td>int execle(const char *pathname, const char *arg, ..., char *const envp[])</td>    </tr>    <tr>        <td>int execve(const char *pathname, char *const argv[], char *const envp[])</td>    </tr>    <tr><td>int execvp(const char *filename, char *const argv[])</td>    </tr>    <tr>        <td>int execlp(const char *filename, const char *arg, ...)</td>    </tr>    <tr>        <td rowspan="2">函数返回值</td>        <td>成功：函数不会返回</td>    </tr>    <tr>        <td>出错：返回-1，失败原因记录在error中</td>    </tr></table><h4 id="命名语法"><a href="#命名语法" class="headerlink" title="命名语法"></a>命名语法</h4><table>    <tr>        <td>前4位</td>        <td colspan="2">统一为：exec</td>    </tr>    <tr>        <td rowspan="2">第5位</td>        <td>l：参数传递为逐个列举方式</td>        <td>execl、execle、execlp</td>    </tr>    <tr>        <td>v：参数传递为构造指针数组方式</td>        <td>execv、execve、execvp</td>    </tr>    <tr>        <td rowspan="2">第6位</td>        <td>e：可传递新进程环境变量</td>        <td>execle、execve</td>    </tr>    <tr>        <td>p：可执行文件查找方式为文件名</td>        <td>execlp、execvp</td>    </tr></table><h5 id="简单例子-1"><a href="#简单例子-1" class="headerlink" title="简单例子"></a>简单例子</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>程序执行execlp函数和execv函数<br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;unistd.h&gt;</span><br><span class="hljs-comment">#include &lt;stdlib.h&gt;</span><br>int main()<br>&#123;<br>pid_t pid;<br><br><span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>创建子进程child_1<br>&#123;<br><span class="hljs-regexp">//</span>错误处理<br>perror(<span class="hljs-string">&quot;fork&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-regexp">//</span>子进程child_1<br>printf(<span class="hljs-string">&quot;\nThis is child_1 process\n&quot;</span>);<br><span class="hljs-keyword">if</span>(execlp(<span class="hljs-string">&quot;pwd&quot;</span>,<span class="hljs-string">&quot;pwd&quot;</span>,NULL) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>转入执行pwd命令<br>&#123;<br>perror(<span class="hljs-string">&quot;execlp&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>printf(<span class="hljs-string">&quot;never be displayed&quot;</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span>创建以NULL结尾的字符串数组指针以便execv函数使用<br>char *arg[] = &#123;<span class="hljs-string">&quot;ls&quot;</span>,NULL&#125;;<br><span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>创建子进程child_2<br>&#123;<br>perror(<span class="hljs-string">&quot;fork&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-regexp">//</span>子进程child_2<br>printf(<span class="hljs-string">&quot;\nThis is child_2 process\n&quot;</span>);<br><span class="hljs-keyword">if</span>(execv(<span class="hljs-string">&quot;/bin/ls&quot;</span>,arg) &lt; <span class="hljs-number">0</span>)<span class="hljs-regexp">//</span>转入执行ls命令<br>&#123;<br>perror(<span class="hljs-string">&quot;execv&quot;</span>);<br><span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>printf(<span class="hljs-string">&quot;never be displayed&quot;</span>);<br>&#125;<br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/exec%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="三、singal函数"><a href="#三、singal函数" class="headerlink" title="三、singal函数"></a>三、singal函数</h3><h4 id="功能说明-2"><a href="#功能说明-2" class="headerlink" title="功能说明"></a>功能说明</h4><p>通过signal函数可以设置系统对于某一信号的对应的操作<br>所在函数库：#include &lt;signal.h&gt;<br>使用原型：signal(int signum,sighandler_t handler)<br>参数说明：<br>signum：信号编号<br>handler的取值：<br>忽略该信号：SIG_IGN<br>执行系统默认动作：SIG_DFL<br>自定义信号处理函数：信号处理函数名</p><h4 id="简单例子-2"><a href="#简单例子-2" class="headerlink" title="简单例子"></a>简单例子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-comment">//注册printsignum函数以便使用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printsignum</span><span class="hljs-params">(<span class="hljs-type">int</span> SignNum)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The signal number is %d\n&quot;</span>,SignNum);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is a process\n&quot;</span>);<br><span class="hljs-built_in">signal</span>(SIGINT,printsignum);<span class="hljs-comment">//注册SIGINT信号,键接收到该信号后会执行printsignum函数</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<span class="hljs-comment">//键入ctrl+c 执行pirntsignum函数</span><br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Never be displayed\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/signal%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p><h3 id="四、make函数的使用"><a href="#四、make函数的使用" class="headerlink" title="四、make函数的使用"></a>四、make函数的使用</h3><h4 id="功能说明-3"><a href="#功能说明-3" class="headerlink" title="功能说明"></a>功能说明</h4><p>使用make命令，系统会在当前目录下寻找Makefile的文件，并对它进行解释，处理，并执行相关动作。</p><h4 id="简单例子-3"><a href="#简单例子-3" class="headerlink" title="简单例子"></a>简单例子</h4><p>主程序main通过调用函数function_A执行相关操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//主函数中调用函数function_A</span><br><span class="hljs-built_in">function_A</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数function_A在同一目录下的另一c文件function_A.c中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function_A</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//输出相关文字</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is function_A\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在同一目录下的makefile文件内容如下</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-symbol">all:</span> main.<span class="hljs-keyword">c</span> function_A.<span class="hljs-keyword">c</span><br>gcc -o all main.<span class="hljs-keyword">c</span> function_A.<span class="hljs-keyword">c</span> #次行以tab开头<br></code></pre></td></tr></table></figure><p>在此目录下键入make命令，发现目录下生成了名为all的可执行文件，执行这个文件，观察到所需的操作已经执行，结果如下：<br><img src="/img/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/make%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>Linux C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识原型设计</title>
    <link href="/2022/10/02/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/10/02/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="事先说明"><a href="#事先说明" class="headerlink" title="事先说明"></a>事先说明</h3><p>其实主要是设计方面，个人艺术细胞不太好，没有美观的界面，只是设计了一个模型出来，无法实现其功能，这次是两人结队完成的哦</p><h3 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h3><h4 id="1-Need-需求"><a href="#1-Need-需求" class="headerlink" title="1.Need 需求"></a>1.Need 需求</h4><ul><li>班级名单导入或生成，要方便易用</li><li>班级点名方式要方便易用</li><li>班级点名方式要尽可能防作弊</li><li>要支持多班级功能</li><li>要支持期末汇总统计导出</li><li>要支持请假功能</li><li>要符合小程序的规范的界面或功能要求</li></ul><h4 id="2-Approach-做法"><a href="#2-Approach-做法" class="headerlink" title="2.Approach 做法"></a>2.Approach 做法</h4><p>（1）使用原型设计工具墨刀设计基于微信小程序的课堂签到小程序；<br>（2）学生端实现学生的课堂签到、签到记录查询；<br>（3）教师端支持发布签到、管理班级、导出名单等功能。</p><h4 id="3-Benefit-好处"><a href="#3-Benefit-好处" class="headerlink" title="3.Benefit 好处"></a>3.Benefit 好处</h4><p>（1）采用分模块、分层次实现，UI简洁明了，方便用户使用；<br>（2）不同的身份定位提供不同的服务；<br>（3）采用扫码加定位签到方式，在一定程度上防止作弊.</p><h4 id="4-Competitors-竞争"><a href="#4-Competitors-竞争" class="headerlink" title="4.Competitors 竞争"></a>4.Competitors 竞争</h4><p>经调研，在本校内师生大多数使用“e点课堂”以及“雨课堂”两款小程序。其中e点并不支持教师导入导出班级成员名单，且仅采用扫码方式进行签到，缺乏有效防作弊手段；雨课堂虽然提供了共享课件以及课堂互动特色功能，但在签到功能需求上采用扫码或课堂码方式签到，也是缺乏有效防作弊手段，且两者都无请假功能。<br>本小程序集成扫码这一便利方式的同时采用自动获取定位来确保学生课堂到位情况真实性，增设请假功能模块，且轻便小巧。</p><h4 id="5-Delivery-推广"><a href="#5-Delivery-推广" class="headerlink" title="5.Delivery 推广"></a>5.Delivery 推广</h4><p>先于本课堂试行，在不断吸收用户反馈意见以及改进的基础上，再向学院、学校、地区、逐级推广。</p><h3 id="二、软件概述"><a href="#二、软件概述" class="headerlink" title="二、软件概述"></a>二、软件概述</h3><h4 id="1-系统功能框架"><a href="#1-系统功能框架" class="headerlink" title="1.系统功能框架"></a>1.系统功能框架</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E6%95%99%E5%B8%88%E7%AB%AF1.jpg"><br><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E7%94%9F%E7%AB%AF1.jpg"></p><h4 id="2-功能逻辑流程图"><a href="#2-功能逻辑流程图" class="headerlink" title="2.功能逻辑流程图"></a>2.功能逻辑流程图</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E6%95%99%E5%B8%88%E7%AB%AF2.jpg#pic_center"><br><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E5%AD%A6%E7%94%9F%E7%AB%AF2.jpg#pic_center"></p><h3 id="三、PSP表格"><a href="#三、PSP表格" class="headerlink" title="三、PSP表格"></a>三、PSP表格</h3><table><thead><tr><th>Personal Software Process Stages</th><th>预估耗时（分钟）</th><th>实际耗时（分钟）</th></tr></thead><tbody><tr><td>Planning（计划）</td><td>60</td><td>30</td></tr><tr><td>Estimate（估计时间）</td><td>10</td><td>5</td></tr><tr><td>Development（开发）</td><td>0</td><td>0</td></tr><tr><td>Analysis（需求分析（包括学习新技术））</td><td>60</td><td>90</td></tr><tr><td>Design Spec（生成设计文档）</td><td>30</td><td>60</td></tr><tr><td>Design Review（设计复审）</td><td>0</td><td>0</td></tr><tr><td>Coding Standard（代码规范 ）</td><td>0</td><td>0</td></tr><tr><td>Design（具体设计）</td><td>400</td><td>500</td></tr><tr><td>Coding（具体编码）</td><td>0</td><td>0</td></tr><tr><td>Code Review（代码复审）</td><td>0</td><td>0</td></tr><tr><td>Test（测试（自我测试，修改代码，提交修改））</td><td>0</td><td>0</td></tr><tr><td>Test Report（测试报告）</td><td>0</td><td>0</td></tr><tr><td>Size Measurement（计算工作量）</td><td>10</td><td>15</td></tr><tr><td>Postmortem &amp; Process Improvement Plan（事后总结, 并提出过程改进计划）</td><td>30</td><td>20</td></tr><tr><td>Total（合计）</td><td>600</td><td>720</td></tr></tbody></table><h3 id="四、纸画原型以及结对照片"><a href="#四、纸画原型以及结对照片" class="headerlink" title="四、纸画原型以及结对照片"></a>四、纸画原型以及结对照片</h3><h4 id="1-原型草图"><a href="#1-原型草图" class="headerlink" title="1. 原型草图"></a>1. 原型草图</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E8%8D%89%E5%9B%BE1.jpg"><br><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E8%8D%89%E5%9B%BE2.jpg"></p><h4 id="2-结对照片"><a href="#2-结对照片" class="headerlink" title="2.结对照片"></a>2.结对照片</h4><p><img src="/img/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/%E7%BB%93%E9%98%9F%E7%85%A7%E7%89%87.jpg"></p><h3 id="五、原型设计"><a href="#五、原型设计" class="headerlink" title="五、原型设计"></a>五、原型设计</h3><p><a href="https://modao.cc/app/aA3ugTpTriyahoqHlBZVTF%20#%E7%AD%BE%E5%88%B0%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%88%86%E4%BA%AB">[原型链接]</a></p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><ul><li>032002603：本次结队作业我基本上学会了设计一个软件原型的基本流程，以及掌握了使用墨刀进行原型设计的简单操作，在功能设计上大致上满足了我们预先的想法，但是在界面美感上可能还需要进行一定的优化。</li><li>032002604：我之前有做过产品功能需求分析并以文档形式呈现的经历，但是本次作业是我首次针对用户需求进行产品设计，这和单纯的收集并分析用户需求是种截然不同的体验。要设计出一款好的产品需要先考虑基础框架，再决定细节实现。对我来说，这是一次对计算机工作者的认知提升。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>作业</tag>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自我介绍</title>
    <link href="/2022/09/16/introducemyself/"/>
    <url>/2022/09/16/introducemyself/</url>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>我是2020级计算机类6班的一名学生，大学之中没有什么亮眼的表现，在班级和年级中几乎是小透明的存在。自己学业一般，虽然一直抱着得过且过的心态，但是自己确确实实有努力学习课程（毕竟自己的智商不允许我太随便了）。<br>我觉得自己么什么感兴趣的东西，真要说的话就是平时爱听歌吧（周董YYDS  (≧▽≦ )&#x2F; )，还有就是之前大一的时候没事就喜欢睡觉。</p><p><img src="/img/introduce/Jay.jpg"></p><h2 id="自我能力评估"><a href="#自我能力评估" class="headerlink" title="自我能力评估"></a>自我能力评估</h2><p>自己代码能力不强，课外自学基本也都是心血来潮，很多时候都是东一点，西一点，到头来都是皮毛，不经常使用就忘掉了。自己基本上没参加过什么团队的开发项目，这也是我的硬伤。</p><ul><li><p>我掌握的</p><ul><li>c&#x2F;c++基础</li><li>数据结构的皮毛</li><li>web前端（目前只会一点html css）</li><li>java基础</li></ul></li><li><p>我缺少的</p><ul><li>实践经验</li><li>团队协作能力</li><li>一套完整的软件开发流程</li><li>后端开发的深入研究</li><li>课外自学能力</li></ul></li></ul><h2 id="未来期望"><a href="#未来期望" class="headerlink" title="未来期望"></a>未来期望</h2><p>自我感觉自己的学习效率不高，脑子也没有同龄的同学们这么灵光，而计算机这门学科又是如此的日新月异，想要跟上节奏还要加把劲，不断地学习。还有期待自己在实习工作能够尽量的积累经验，这方面的经验自己也是非常的缺少，先在福州工作一段时间，能够在家乡找到好的工作那当然更好。</p><p>ps:基本上是作业一里的内容</p>]]></content>
    
    
    
    <tags>
      
      <tag>自我介绍</tag>
      
      <tag>作业</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>破站上线</title>
    <link href="/2022/09/15/firstblog/"/>
    <url>/2022/09/15/firstblog/</url>
    
    <content type="html"><![CDATA[<h2 id="简单说一说"><a href="#简单说一说" class="headerlink" title="简单说一说"></a>简单说一说</h2><p>这个网站是自己瞎捣鼓了好几天，终于稍微有点雏形了的，小白搭建网站没有那么花里胡哨。希望以后继续努力吧，加油鸭！！！</p><p><img src="/img/firstblog/fighting.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>说明</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
